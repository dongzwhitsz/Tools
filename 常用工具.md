# 常用工具

- [ ] 网络工具
- [ ] 文本工具
- [ ] shell脚本

## 网络工具

### nc

文档说明：

```sh
nc [-hlnruz][-g<网关...>][-G<指向器数目>][-i<延迟秒数>][-o<输出文件>][-p<通信端口>][-s<来源位址>][-v...][-w<超时秒数>][主机名称][通信端口...]
```

> **参数说明**：
>
> - -g<网关> 设置路由器跃程通信网关，最多可设置8个。
> - -G<指向器数目> 设置来源路由指向器，其数值为4的倍数。
> - -h 在线帮助。
> - -i<延迟秒数> 设置时间间隔，以便传送信息及扫描通信端口。
> - -k Forces nc to stay listening for another connection after its current connection is completed.  It is an error to use this option without the -l option.
> - -l 使用监听模式，管控传入的资料。
> - -n 直接使用IP地址，而不通过域名服务器。
> - -o<输出文件> 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。
> - -p<通信端口> 设置本地主机使用的通信端口。
> - -r 乱数指定本地与远端主机的通信端口。
> - -s<来源位址> 设置本地主机送出数据包的IP地址。
> - -u 使用UDP传输协议。
> - -v 显示指令执行过程。
> - -w<超时秒数> 设置等待连线的时间。
> - -z 使用0输入/输出模式，只在扫描通信端口时使用。

```sh
# TCP端口扫描
nc -v -z -w2 192.168.0.3 1-100
# UDP端口扫描
nc -u -z -w2 192.168.0.1 1-1000 # 扫描192.168.0.3 的端口 范围是 1-1000
# 指定端口扫描
nc -nvv 192.168.0.1 80 #扫描 80端口
nc -l 1337 | /bin/bash # NB
```



**[NB]** 在服务器上，执行下面两个命令，这就构造了一个循环。

```java
rm -f /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/bash 2>&1 | nc -l  5879 > /tmp/f
```

客户端nc连接以后，竟然直接出现了命令行操作终端！

```java
$ nc -v 192.16.1.54 5879
Connection to 192.16.1.54 port 5879 [tcp/*] succeeded!
[root@localhost~]#
```

你可能会说，我客户端关掉之后，为什么服务端的命令也退出了？如果你想要服务端继续监听，可以加上参数`-k`。





文件和目录的传送

服务端同样监听一个端口，但是这次把重定向定向到一个文件。

```sh
nc -l 5879 > file
```

客户端就可以启动一个命令将文件发送过去。这次是使用反向的箭头。

```shell
nc -v 192.16.1.54 5879 < redis-5.0.5.tar.gz
```

文件传的飞快！而且由于没有rsa那一套的加密，速度更快了。

我知道你的脑子里现在在想着怎么传送目录了。这个过程很有意思。

我们把nc的输出，使用管道交给tar命令处理。`xfvz`和`cvfz`是一对参数，你应该猜到要怎么做了。

```java
nc -l 5879  | tar -xfvz 
```

没错，客户端的代码与上面的是相反的。不过这次，我们的nc命令接收了打包的文件。

```java
tar -cfz redis-5.0.5 |  nc -v 192.16.1.54 5879
```

真的是非常巧妙。



### curl

> curl  is  a tool to transfer data from or to a server,

```shell
# 调试类
 -v, --verbose                          输出信息
 -q, --disable                          在第一个参数位置设置后 .curlrc 的设置直接失效，这个参数会影响到 -K, --config       -A, --user-agent -e, --referer
 -K, --config FILE                      指定配置文件
 -L, --location                         跟踪重定向 (H)
 ​
 # CLI显示设置
 -s, --silent                           Silent模式。不输出任务内容
 -S, --show-error                       显示错误. 在选项 -s 中，当 curl 出现错误时将显示
 -f, --fail                             不显示 连接失败时HTTP错误信息
 -i, --include                          显示 response的header (H/F)
 -I, --head                             仅显示 响应文档头
 -l, --list-only                        只列出FTP目录的名称 (F)
 -#, --progress-bar                     以进度条 显示传输进度
 ​
 # 数据传输类
 -X, --request [GET|POST|PUT|DELETE|…]  使用指定的 http method 例如 -X POST
 -H, --header <header>                  设定 request里的header 例如 -H "Content-Type: application/json"
 -e, --referer                          设定 referer (H)
 -d, --data <data>                      设定 http body 默认使用 content-type application/x-www-form-urlencoded (H)
     --data-raw <data>                  ASCII 编码 HTTP POST 数据 (H)
     --data-binary <data>               binary 编码 HTTP POST 数据 (H)
     --data-urlencode <data>            url 编码 HTTP POST 数据 (H)
 -G, --get                              使用 HTTP GET 方法发送 -d 数据 (H)
 -F, --form <name=string>               模拟 HTTP 表单数据提交 multipart POST (H)
     --form-string <name=string>        模拟 HTTP 表单数据提交 (H)
 -u, --user <user:password>             使用帐户，密码 例如 admin:password
 -b, --cookie <data>                    cookie 文件 (H)
 -j, --junk-session-cookies             读取文件中但忽略会话cookie (H)
 -A, --user-agent                       user-agent设置 (H)
 ​
 # 传输设置
 -C, --continue-at OFFSET               断点续转
 -x, --proxy [PROTOCOL://]HOST[:PORT]   在指定的端口上使用代理
 -U, --proxy-user USER[:PASSWORD]       代理用户名及密码
 ​
 # 文件操作
 -T, --upload-file <file>               上传文件
 -a, --append                           添加要上传的文件 (F/SFTP)
 ​
 # 输出设置
 -o, --output <file>                    将输出写入文件，而非 stdout
 -O, --remote-name                      将输出写入远程文件
 -D, --dump-header <file>               将头信息写入指定的文件
 -c, --cookie-jar <file>                操作结束后，要写入 Cookies 的文件位置
```



```sh
# 语法
curl [option] [url]
#  -x, --proxy [PROTOCOL://]HOST[:PORT]  Use proxy on given port
#  -#, --progress-bar  Display transfer progress as a progress bar
#  -I, --head          Show document info only
#  -H, --header LINE   Pass custom header LINE to server (H)
#  -G, --get           Send the -d data with a HTTP GET (H)
#  -F, --form CONTENT  Specify HTTP multipart POST data (H)
#  -f, --fail          Fail silently (no output at all) on HTTP errors (H)
#  -d, --data DATA     HTTP POST data (H)
#  -c, --cookie-jar FILE  Write cookies to FILE after operation (H) 保存cookie
#  -b, --cookie STRING/FILE  Read cookies from STRING/FILE (H)

# 最简单的使用，获取服务器内容，默认将输出打印到标准输出中(STDOUT)中。
curl http://www.centos.org

# 添加-v参数可以看到详细解析过程，通常用于debug
curl -v http://www.centos.org

# curl发送Get请求
curl URL
curl URL -O 文件绝对路径

# curl发送post请求

# 请求主体用json格式
curl -X POST -H 'content-type: application/json' -d @json文件绝对路径 URL
curl -X POST -H 'content-type: application/json' -d 'json内容' URL
# 请求主体用xml格式
curl -X POST -H 'content-type: application/xml' -d @xml文件绝对路径 URL
curl -X POST -H 'content-type: application/xml' -d 'xml内容' URL

# 设置cookies
curl URL --cookie "cookie内容"
curl URL --cookie-jar cookie文件绝对路径

# 设置代理字符串
curl URL --user-agent "代理内容"
curl URL -A "代理内容"

# curl限制带宽
curl URL --limit-rate 速度

# curl认证
curl -u user:pwd URL
curl -u user URL

# 只打印http头部信息
curl -I URL
curl -head URL

# 末尾参数
--progress  显示进度条
--silent    不现实进度条

# 不需要修改/etc/hosts，curl直接解析ip请求域名
# 将 http://example.com 或 https://example.com 请求指定域名解析的IP为127.0.0.1
curl --resolve example.com:80:127.0.0.1 http://example.com/
curl --resolve example.com:443:127.0.0.1 https://example.com/
```



1. Nmap
2. nginx



[aria](https://aria2.github.io/)

```shell
aria2c url/bt  # 下载 
```

curl支持的协议

DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET or TFTP



## 文本工具

文本工具

1. grep
2. sed
3. awk
4. find



awk -F '#' '{print $1,$2}' test

sed  [options]... 'script' inputfile

**选项**

1. -n：不输出模式空间内容到屏幕，即不自动打印
2. -e：多点编辑
3. -f /PATH/SCRIPT_FILE：从指定文件中读取编辑脚本
4. -r：支持使用扩展正则表达式
5. -i：直接编辑文件
6. -i.bak：备份文件并原处编辑

d 删除模式空间匹配的行，并立即启用下一轮循环

p 显示符合条件的行，追加到默认输出之后

a [\]text1 在指定行后面追加文本,支持使用\n实现多行追加

i [\]text 在行前面插入文本

c [\]text 替换行为单行或多行文本

w /path/somefile 保存模式匹配的行至指定文件

r /path/somefile 读取指定文件的文本至模式空间中匹配到的行后

= 为模式空间中的行打印行号

! 模式空间中匹配行取反处理

s///：查找替换,支持使用其它分隔符，s@@@，s###

1. g 默认只匹配行中第一次出现的内容，加上g，就可以全文替换了。常用。
2. p 显示替换成功的行
3. w /PATH/TO/SOMEFILE 将替换成功的行保存至文件中
4. **i** 这个参数比较重要，表示忽略大小写。



**sed -n 2p test 打印第 2 行内容**

**sed -n 2,5p test 打印第 2--5 行内容**

**sed -i 's/a/v/g' test 将文件中的 a 全部替换为 v 「sed替换格式是：sed -i ‘s/要替换的内容/替换成的内容/g' 文件名」**

sed -i '/dongzw/adongzw niubiable' text.txt 在text.txt中的所有dongzw之后添加niubiable(新起了一行)

```shell
  JAVA_HOME=/opt/$JDK_NAME
  JRE_HOME=$JAVA_HOME/jre
  cat << EOF >> /etc/profile
export JAVA_HOME=$JAVA_HOME
export JRE_HOME=$JRE_HOME
export CLASSPATH=.:\$JAVA_HOME/jre/lib/rt.jar:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar
export PATH=\$PATH:\$JAVA_HOME/bin:/usr/local/bin
EOF
  sed -i '/<mirrors>/a\
    <mirror>\
      <id>aliyunmaven</id>\
      <mirrorOf>*</mirrorOf>\
      <name>阿里云公共仓库</name>\
      <url>https://maven.aliyun.com/repository/public</url>\
    </mirror>' $MAVEN_HOME/conf/settings.xml
```



但也有高级功能。和java或者python的正则api类似，sed的替换同样有`Matched Pattern`的含义，同样可以得到Group，不深究。常用的替位符，就是`&`。

**`&`**号，再重复一遍。当它用在替换字符串中的时候，代表的是原始的查找匹配数据。

> **[&]** 表明将查找到的数据使用[]包围起来。
>  **“&”** 表明将查找的数据使用””包围起来。
>  

下面这条命令，将会把文件中的每一行，使用引号包围起来。

```text
sed 's/.*/"&"/' file
```



grep -i 'b' test 在文件 test 中查找字符 b

- -w：匹配整个单词
- -A：after ，显示后行
- -B：before ，显示前行
- -C：context，显示前后行
- -E：相当于 egrep，即 grep -E = egrep







其语法格式为：

```sh
cut [-bn] [file] 或 cut [-c] [file] 或 cut [-df] [file]
```

使用说明：

`cut` 命令从文件的每一行剪切字节、字符或字段并将这些字节、字符或字段写至标准输出。

如果不指定 `file` 参数， `cut` 命令将读取标准输入。 必须指定 `-b`、`-c` 或 `-f` 标志之一。

主要参数含义： - `-b`: 以字节为单位进行分割 - `-c`: 以字符为单位进行分割 - `-d`: 自定义分隔符进行分割，默认为制表符号 - `-f`: 与 `-d` 一起使用，用分隔符分割后，指定显示哪些部分 - `-n`：取消分割多字节字符，仅和 `-b` 标志一起使用。



```sh
# 保留 1 到 24 之间（闭区间）的字符
cut -c -24 BALANCE.txt

# 保留 1 到 24（闭区间）以及 36 到 59（闭区间）之间的字符
cut -c -24,36-59 BALANCE.txt

# 保留 1 到 24（闭区间）、36 到 59（闭区间）和 93 到该行末尾之间的字符
cut -c -24,36-59,93- BALANCE.txt

```



tr命令用于转换或删除字符。

```sh
tr [–c/d/s/t] [SET1] [SET2]
SET1/SET2: 字符集
-c: complement，用SET2替换SET1中没有包含的字符
-d: delete，删除SET1中所有的字符，不转换
-s: squeeze-repeats，压缩SET1中重复的字符，即删除重复的字符
-t: truncate-set1，将SET1用SET2替换，一般缺省为-t
-c：complement，用SET2替换SET1中没有包含的字符

# 不想要多余的换行
cat test | tr -s "\n"
# 删除所有的换行
cat test | tr -d "\n"
# 大小写转换
echo "my name is caipengxiang" | tr -t [a-z] [A-Z]
# 删除指定字符
cat test | tr -d "[0-9][.][\-][ ]"

```

```sh
[~]$cat test | tr -d "[0-9][.][\-][ ]"

#test



trtranslate


helloworld
[~]$cat test | tr -cs "[a-z][A-Z]" "\n"

test
tr
translate
hello
world
```

-c: 用换行符"\n"替换掉字母以外的所有字符；

-s：删除多余的换行符。



## 性能工具

https://support.huaweicloud.com/tuningtip-kunpenggrf/kunpengtuning_12_0002.html

### numactl工具

```shell
# yum -y install numactl numastat
```

>  现在的机器上都是有多个CPU和多个内存块的。以前我们都是将内存块看成是一大块内存，所有CPU到这个共享内存的访问消息是一样的。这就是之前普遍使用的SMP模型。但是随着处理器的增加，共享内存可能会导致内存访问冲突越来越厉害，且如果内存访问达到瓶颈的时候，性能就不能随之增加。NUMA（Non-Uniform Memory Access）就是这样的环境下引入的一个模型。比如一台机器是有2个处理器，有4个内存块。我们将1个处理器和两个内存块合起来，称为一个NUMA node，这样这个机器就会有两个NUMA node。在物理分布上，NUMA node的处理器和内存块的物理距离更小，因此访问也更快。比如这台机器会分左右两个处理器（cpu1, cpu2），在每个处理器两边放两个内存块(memory1.1, memory1.2, memory2.1,memory2.2)，这样NUMA node1的cpu1访问memory1.1和memory1.2就比访问memory2.1和memory2.2更快。所以使用NUMA的模式如果能尽量保证本node内的CPU只访问本node内的内存块，那这样的效率就是最高的。
>
> 在运行程序的时候使用numactl -m和-physcpubind就能制定将这个程序运行在哪个cpu和哪个memory中。玩转cpu-topology 给了一个表格，当程序只使用一个node资源和使用多个node资源的比较表（差不多是38s与28s的差距）。所以限定程序在numa node中运行是有实际意义的。
>
> 但是呢，话又说回来了，制定numa就一定好吗？--numa的陷阱。SWAP的罪与罚文章就说到了一个numa的陷阱的问题。现象是当你的服务器还有内存的时候，发现它已经在开始使用swap了，甚至已经导致机器出现停滞的现象。这个就有可能是由于numa的限制，如果一个进程限制它只能使用自己的numa节点的内存，那么当自身numa node内存使用光之后，就不会去使用其他numa node的内存了，会开始使用swap，甚至更糟的情况，机器没有设置swap的时候，可能会直接死机！所以你可以使用numactl --interleave=all来取消numa node的限制。
>
> 综上所述得出的结论就是，根据具体业务决定NUMA的使用。
>
>
> 如果你的程序是会占用大规模内存的，你大多应该选择关闭numa node的限制。因为这个时候你的程序很有几率会碰到numa陷阱。
>
> 另外，如果你的程序并不占用大内存，而是要求更快的程序运行时间。你大多应该选择限制只访问本numa node的方法来进行处理。



```shell
numactl - 用于控制 进程与共享存储的 NUMA 技术机制

语法：

numactl [--interleave nodes] [--preferred node] [--membind nodes]
  [--cpunodebind nodes] [--physcpubind cpus] [--localalloc] [--] {arguments ...}
numactl --show
numactl --hardware
numactl [--huge] [--offset offset] [--shmmode shmmode] [--length length] [--strict]
[--shmid id] --shm shmkeyfile | --file tmpfsfile
[--touch] [--dump] [--dump-nodes] memory policy

主要参数：

--interleave=nodes, -i nodes


          这个选项用于设定内存的交织分配模式。 也就是说系统在为多个节点分配内存空间的时候，将会以轮询分发的方式被分配给这多个节点.
          如果在当前众多的交织分配内存节点中的目标节点无法正确的分配内存空间的话，内存空间将会由其他的节点来分配。


--membind=nodes, -m nodes
           选项 '--membind' 仅用来从节点中分配内存空间所用。 如果在这些节点中无法分配出所请求的空间大小的话该分配操作将会失败.
           上述命令中指定需要分配空间的 nodes 的方式可以遵照上述 N,N,N , N-N ,N 这种方式来指定.


--cpunodebind=nodes, -N nodes
          上述命令仅用于施加在运行与 cpu 上的进程。这个命令用于显示 cpu 的个数，cpu 数目信息同样记录在系统中的存放处理器领域信息的 /proc/cpuinfo 文件夹下，
          或者是按照关联的中央处理器信息 在当前的中央处理器集中所存放. 
```



从**numactl**执行结果可以看到，示例服务器共划分为4个NUMA节点。每个节点包含16个CPU core，每个节点的内存大小约为64GB。同时，该命令还给出了不同节点间的距离，距离越远，跨NUMA内存访问的延时越大。应用程序运行时应减少跨NUMA访问内存。

![](https://support.huaweicloud.com/tuningtip-kunpenggrf/zh-cn_image_0228798102.png)

通过**numactl**将进程绑定到指定CPU core。

通过 numactl -C 0-15 top 命令即是将进程“top”绑定到0~15 CPU core上执行。

![](https://support.huaweicloud.com/tuningtip-kunpenggrf/zh-cn_image_0228798104.png)

通过**numastat**查看当前NUMA节点的内存访问命中率。

![](https://support.huaweicloud.com/tuningtip-kunpenggrf/zh-cn_image_0228798106.png)

可以通过**numastat**命令观察各个NUMA节点的状态。

- numa_hit表示节点内CPU核访问本地内存的次数。
- numa_miss表示节点内核访问其他节点内存的次数。跨节点的内存访问会存在高延迟从而降低性能，因此，numa_miss的值应当越低越好，如果过高，则应当考虑绑核。

### top工具

https://blog.csdn.net/weixin_42500678/article/details/80754737

### perf工具



## shell脚本

shell执行脚本的方式

> 1、在当前shell中执行【相对或绝对路径下都行】，这两个本质是一样的
>  	source script_file_name
>  	. script_file_name 中间有1个空格
> 2、在当前shell（父进程）开启一个【子shell（子进程）】中执行，
> 脚本一旦执行完后子shell环境将随即关闭，然后又回到父shell中，而无法再访问脚本中的变量的（不管有没有export）。
> 【无论脚本中是否有#!/bin/bash这行，都会开启子shell去执行】
>  	sh script_file_name
>  	相对或绝对路径/script_file_name【若脚本无#!/bin/bash，则会选择系统默认shell执行它】



[shell必备脚本30道](https://www.huaweicloud.com/articles/149a08dc02582d428b7188270bd8dffd.html)

> 1、[ ]表示条件测试。注意这里的空格很重要。要注意在'['后面和']'前面都必须要有空格
> 2、在shell中，then和fi是分开的语句。如果要在同一行里面输入，则需要用分号将他们隔开。
> 3、注意if判断中对于变量的处理，需要加引号，以免一些不必要的错误。没有加双引号会在一些含空格等的字符串变量判断的时候产生错误。比如[ -n "$var" ]如果var为空会出错
> 4、判断是不支持浮点值的
> 5、如果只单独使用>或者<号，系统会认为是输出或者输入重定向，虽然结果显示正确，但是其实是错误的，因此要对这些符号进行转意
> 6、在默认中，运行if语句中的命令所产生的错误信息仍然出现在脚本的输出结果中
> 7、使用-z或者-n来检查长度的时候，没有定义的变量也为0
> 8、空变量和没有初始化的变量可能会对shell脚本测试产生灾难性的影响，因此在不确定变量的内容的时候，在测试号前使用-n或者-z测试一下
> 9、? 变量包含了之前执行命令的退出状态（最近完成的前台进程）（可以用于检测退出状态）

基本语法

```shell
if [ command ]; then
     符合该条件执行的语句
fi
######################
if [ command ];then
     符合该条件执行的语句
elif [ command ];then
     符合该条件执行的语句
else
     符合该条件执行的语句
fi
```



文件测试

| 参数      | 说明                                 |
| :-------- | :----------------------------------- |
| -e 文件名 | 如果文件存在则为真                   |
| -r 文件名 | 如果文件存在且可读则为真             |
| -w 文件名 | 如果文件存在且可写则为真             |
| -x 文件名 | 如果文件存在且可执行则为真           |
| -s 文件名 | 如果文件存在且至少有一个字符则为真   |
| -d 文件名 | 如果文件存在且为目录则为真           |
| -f 文件名 | 如果文件存在且为普通文件则为真       |
| -c 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| -b 文件名 | 如果文件存在且为块特殊文件则为真     |

```shell
常用的：
[ -a FILE ] 如果 FILE 存在则为真。
[ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。
[ -e FILE ] 如果 指定的文件或目录存在时返回为真。
[ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。
[ -r FILE ] 如果 FILE 存在且是可读的则返回为真。
[ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的）
[ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。

不常用的：
[ -b FILE ] 如果 FILE 存在且是一个块文件则返回为真。
[ -c FILE ] 如果 FILE 存在且是一个字符文件则返回为真。
[ -g FILE ] 如果 FILE 存在且设置了SGID则返回为真。
[ -h FILE ] 如果 FILE 存在且是一个符号符号链接文件则返回为真。（该选项在一些老系统上无效）
[ -k FILE ] 如果 FILE 存在且已经设置了冒险位则返回为真。
[ -p FILE ] 如果 FILE 存并且是命令管道时返回为真。
[ -s FILE ] 如果 FILE 存在且大小非0时为真则返回为真。
[ -u FILE ] 如果 FILE 存在且设置了SUID位时返回为真。
[ -O FILE ] 如果 FILE 存在且属有效用户ID则返回为真。
[ -G FILE ] 如果 FILE 存在且默认组为当前组则返回为真。（只检查系统默认组）
[ -L FILE ] 如果 FILE 存在且是一个符号连接则返回为真。
[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则返回为真。
[ -S FILE ] 如果 FILE 存在且是一个套接字则返回为真。
[ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新, 或者 FILE1 存在但是 FILE2 不存在则返回为真。
[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 老, 或者 FILE2 存在但是 FILE1 不存在则返回为真。
[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则返回为真。

字符串判断
[ -z STRING ] 如果STRING的长度为零则返回为真，即空是真
[ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真
[ STRING1 ]　 如果字符串不为空则返回为真,与-n类似
[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真
[ STRING1 != STRING2 ] 如果字符串不相同则返回为真
[ STRING1 < STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。
[ STRING1 > STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。

数值判断
[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,<>
[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,>
[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,>=
[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,<
[ INT1 -le INT2 ] INT1小于等于INT2返回为真,<=

逻辑判断
[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
[ ] || [ ] 用OR来合并两个条件
[ ] && [ ] 用AND来合并两个条件

[ -t FD ] 如果文件描述符 FD （默认值为1）打开且指向一个终端则返回为真
[ -o optionname ] 如果shell选项optionname开启则返回为真
```

IF高级特性：
双圆括号(( ))：表示数学表达式
在判断命令中只允许在比较中进行简单的算术操作，而双圆括号提供更多的数学符号，而且在双圆括号里面的'>','<'号不需要转意。

双方括号[[ ]]：表示高级字符串处理函数
双方括号中判断命令使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。

```sh
for i in `seq 1 10`; do ip="192.168.1.$i"; x=`ping -c 1 $ip` > /dev/null; if [ $x != 0 ]; then echo success $ip; else; echo "$ip error"; fi; done;
```





[[ ]]是 Shell 内置关键字，它和 test 命令类似，也用来检测某个条件是否成立。[[ ]] 剔除了 test 命令的-o和-a选项，你只能使用 || 和 &&。

在 Shell [[ ]] 中，可以使用`=~`来检测字符串是否符合某个正则表达式，它的用法为：

```py
	[[ str=~regex ]]
```

str 表示字符串，regex 表示正则表达式。

下面的代码检测一个字符串是否是手机号：

```sh
#!/bin/bash
read tel
if [[ $tel =~ ^1[0-9]{10}$ ]]
then    
	echo "你输入的是手机号码"
else
	echo "你输入的不是手机号码"
fi
```





双括号的作用：
在shell中，[ $a != 1 || $b = 2 ]是不允许出，要用[ $a != 1 ] || [ $b = 2 ]，而双括号就可以解决这个问题的，[[ $a != 1 || $b = 2 ]]。又比如这个[ "$a" -lt "$b" ]，也可以改成双括号的形式(("$a" < "$b"))

> linux中shell变量$#,$@,$0,$1,$2的含义解释: 
> $$ :Shell本身的PID（ProcessID） 
> $! :Shell最后运行的后台Process的PID 
> $? :最后运行的命令的结束代码（返回值） 
> $- :使用Set命令设定的Flag一览 
> $* :所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 
> $@ :所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 
> $# :添加到Shell的参数个数 
> $0 :Shell本身的文件名 
> $1～$n:添加到Shell的各参数值。$1是第1参数、$2是第2参数…。



shell执行文件的监控文件的上传

```shell
#!/bin/bash
today=`date +"%Y-%m-%d"`
#echo $today
hname=`hostname`
#echo $hname
ip=`ifconfig em1 | grep "inet addr" | cut -f 2 -d ":" | cut -f 1 -d " "|cut -f 4 -d "."`
echo $ip
fname="${hname}_${ip}_${today}_$RANDOM.txt"
#echo $fname
FPath="/root/server_monitor/"
echo $FPath
ldir=`pwd`
echo "pwd1:[$ldir]"
[ ! -d $FPath  ] && mkdir $FPath || cd $FPath
echo "pwd2:[$ldir]"
XName=$FPath$fname
echo $XName
sh /root/soft/xcpu.sh > $XName
echo "$XName create ok"
sleep 5
ip="172.29.0.182"
user="server_jk"
passwd="123aA"
lftp <
open $ip -u $user,$passwd
put $XName
close
bye
!
echo "$XName ftp ok"
```

CentOS自动部署LAMP简易脚本

```shell
#!/bin/bash

green='\e[1;32m' # green
red='\e[1;31m' # red
blue='\e[1;34m' # blue  
nc='\e[0m' # normal
#set temp step
clear
# show system info
setselinux(){
  echo -n "Closing Selinx ..."
  sleep 0.3
  sed -i  's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
  echo -n "."
  sleep 0.3
  echo -n "."
  i=`setenforce 0`  
  echo -n $i
  echo -n "Config Selinux ....."
  if [ $? == 0 -o $? == 1 ];then
  	echo -e " [${green}Success${nc}]"
  else
    echo -e "[${red}Failed${nc}]"
    echo "Please check your config.."
    exit 2
  fi
}
install(){
  echo -n "Install $@ ..."
  sleep 0.3
  yum install -y $@ &>/dev/null
  i=$?
  echo -n "."
  sleep 0.3
  if [ $i == 0 ];then
  	echo -e "[${green}Success${nc}]"
  else
    echo -e "[${red}Failed${nc}]"
    echo "Please check your config.."
  exit 3
  fi
}
setcfg(){
  sleep 0.3
  systemctl enable $@ &>/dev/null
  echo -n "Setting start-up ..."
  i=$?
  echo -n '.'
  sleep 0.3
  if [ $i == 0 ];then
  	echo -e "[${green}Success${nc}]"
  else
    echo -e "[${red}Failed${nc}]"
    echo "Please check your config.."
    exit 4
  fi
}
start(){
  echo -n "Starting $@ ..."
  sleep 0.3
  systemctl restart $@ &>/dev/null
  i=$?
  echo -n "."
  sleep 0.3
  if [ $i == 0 ];then
 		echo -e "[${green}Success${nc}]"
  else
    echo -e "[${red}Failed${nc}]"
    echo "Please check your config.."
    exit 5
  fi
}
cat << EOF
=========================================================================
Mr.Funky Auto Install LAMP for CENTOS\REHL 7
=========================================================================
Author: Mr Funky
=========================================================================
USER: $USER   HOST: $HOSTNAME  KERNEL: `uname -r`  
DISK :`ls  /dev/sd?`
Are you sure to auto install LAMP Environment ?
EOF

read -p "Please input Y to continue" key
if [ $key == 'Y' -o $key == 'y' ];then
  setselinux
  install "httpd"
  install "mariadb mariadb-server"
  install "php"
  echo "Installing Extra Tools"
  sleep 0.5
  install "php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash"
  setcfg "httpd"
  setcfg "mariadb"
  /bin/cp -rf  /usr/share/mysql/my-huge.cnf /etc/my.cnf
  start "httpd"
  start "mariadb"
  echo "Set Your MYSQL:"
  sleep 3
  mysql_secure_installation
  echo "reloading Service"
  echo "" > /var/www/html/phpinfo.php
  chown apache.apache -R /var/www/html
  start "httpd"
  start "mariadb"
  echo "Would you like to Optimize apache setting ?"
  read -p "Please input Y to continue" key
  if [ $key == 'Y' -o $key == 'y' ];then
    sed -i  's/#AddHandler cgi-script .cgi/AddHandler cgi-script .cgi/' /etc/httpd/conf/httpd.conf
    sed -i  's/AllowOverride None/AllowOverride All/' /etc/httpd/conf/httpd.conf
    sed -i  's/AddDefaultCharset UTF-8/AddDefaultCharset GB2312/' /etc/httpd/conf/httpd.conf
    start "httpd"
  start "mariadb"
  fi
  echo "You can check your apache : http://localhost"
  echo "You can check your PHP : http://localhost/phpinfo.php"
  echo "All of components are installed. Enjoy~"
  sleep 3
  exit
	fi
else		
  exit 1
fi
```



Nacos的startup.sh

```sh
#!/bin/bash

# Copyright 1999-2018 Alibaba Group Holding Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cygwin=false
darwin=false
os400=false
case "`uname`" in
  CYGWIN*) cygwin=true;;
  Darwin*) darwin=true;;
  OS400*) os400=true;;
esac
error_exit ()
{
    echo "ERROR: $1 !!"
    exit 1
}
[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=$HOME/jdk/java
[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/usr/java
[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/opt/taobao/java
[ ! -e "$JAVA_HOME/bin/java" ] && unset JAVA_HOME

if [ -z "$JAVA_HOME" ]; then
  if $darwin; then

    if [ -x '/usr/libexec/java_home' ] ; then
      export JAVA_HOME=`/usr/libexec/java_home`

    elif [ -d "/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home" ]; then
      export JAVA_HOME="/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home"
    fi
  else
    JAVA_PATH=`dirname $(readlink -f $(which javac))`
    if [ "x$JAVA_PATH" != "x" ]; then
      export JAVA_HOME=`dirname $JAVA_PATH 2>/dev/null`
    fi
  fi
  if [ -z "$JAVA_HOME" ]; then
        error_exit "Please set the JAVA_HOME variable in your environment, We need java(x64)! jdk8 or later is better!"
  fi
fi

export SERVER="nacos-server"
export MODE="cluster"
export FUNCTION_MODE="all"
export MEMBER_LIST=""
export EMBEDDED_STORAGE=""
while getopts ":m:f:s:c:p:" opt
do
    case $opt in
        m)
            MODE=$OPTARG;;
        f)
            FUNCTION_MODE=$OPTARG;;
        s)
            SERVER=$OPTARG;;
        c)
            MEMBER_LIST=$OPTARG;;
        p)
            EMBEDDED_STORAGE=$OPTARG;;
        ?)
        echo "Unknown parameter"
        exit 1;;
    esac
done

export JAVA_HOME
export JAVA="$JAVA_HOME/bin/java"
export BASE_DIR=`cd $(dirname $0)/..; pwd`
export CUSTOM_SEARCH_LOCATIONS=file:${BASE_DIR}/conf/

#===========================================================================================
# JVM Configuration
#===========================================================================================
if [[ "${MODE}" == "standalone" ]]; then
    JAVA_OPT="${JAVA_OPT} -Xms512m -Xmx512m -Xmn256m"
    JAVA_OPT="${JAVA_OPT} -Dnacos.standalone=true"
else
    if [[ "${EMBEDDED_STORAGE}" == "embedded" ]]; then
        JAVA_OPT="${JAVA_OPT} -DembeddedStorage=true"
    fi
    JAVA_OPT="${JAVA_OPT} -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"
    JAVA_OPT="${JAVA_OPT} -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${BASE_DIR}/logs/java_heapdump.hprof"
    JAVA_OPT="${JAVA_OPT} -XX:-UseLargePages"

fi

if [[ "${FUNCTION_MODE}" == "config" ]]; then
    JAVA_OPT="${JAVA_OPT} -Dnacos.functionMode=config"
elif [[ "${FUNCTION_MODE}" == "naming" ]]; then
    JAVA_OPT="${JAVA_OPT} -Dnacos.functionMode=naming"
fi

JAVA_OPT="${JAVA_OPT} -Dnacos.member.list=${MEMBER_LIST}"

JAVA_MAJOR_VERSION=$($JAVA -version 2>&1 | sed -E -n 's/.* version "([0-9]*).*$/\1/p')
if [[ "$JAVA_MAJOR_VERSION" -ge "9" ]] ; then
  JAVA_OPT="${JAVA_OPT} -Xlog:gc*:file=${BASE_DIR}/logs/nacos_gc.log:time,tags:filecount=10,filesize=102400"
else
  JAVA_OPT="${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext"
  JAVA_OPT="${JAVA_OPT} -Xloggc:${BASE_DIR}/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M"
fi

JAVA_OPT="${JAVA_OPT} -Dloader.path=${BASE_DIR}/plugins/health,${BASE_DIR}/plugins/cmdb"
JAVA_OPT="${JAVA_OPT} -Dnacos.home=${BASE_DIR}"
JAVA_OPT="${JAVA_OPT} -jar ${BASE_DIR}/target/${SERVER}.jar"
JAVA_OPT="${JAVA_OPT} ${JAVA_OPT_EXT}"
JAVA_OPT="${JAVA_OPT} --spring.config.additional-location=${CUSTOM_SEARCH_LOCATIONS}"
JAVA_OPT="${JAVA_OPT} --logging.config=${BASE_DIR}/conf/nacos-logback.xml"
JAVA_OPT="${JAVA_OPT} --server.max-http-header-size=524288"

if [ ! -d "${BASE_DIR}/logs" ]; then
  mkdir ${BASE_DIR}/logs
fi

echo "$JAVA ${JAVA_OPT}"

if [[ "${MODE}" == "standalone" ]]; then
    echo "nacos is starting with standalone"
else
    echo "nacos is starting with cluster"
fi

# check the start.out log output file
if [ ! -f "${BASE_DIR}/logs/start.out" ]; then
  touch "${BASE_DIR}/logs/start.out"
fi
# start
echo "$JAVA ${JAVA_OPT}" > ${BASE_DIR}/logs/start.out 2>&1 &
nohup $JAVA ${JAVA_OPT} nacos.nacos >> ${BASE_DIR}/logs/start.out 2>&1 &
echo "nacos is starting，you can check the ${BASE_DIR}/logs/start.out"				

```

getopts后面跟的字符串就是参数列表，每个字母代表一个选项，如果字母后面跟一个：，则就表示这个选项还会有一个值，比如上面例子中对应的-j /data/usw/web 和-m /opt/data/web 。而getopts字符串中没有跟随:的字母就是开关型选项，不需要指定值，等同于true/false,只要带上了这个参数就是true。

getopts识别出各个选项之后，就可以配合case进行操作。操作中，有两个"常量"，一个是OPTARG，用来获取当前选项的值；另外一个就是OPTIND，表示当前选项在参数列表中的位移。case的最后一项是?，用来识别非法的选项，进行相应的操作，我们的脚本中输出了帮助信息。

语法格式：getopts [option[:]] [DESCPRITION] VARIABLE

option：表示为某个脚本可以使用的选项

“:”：如果某个选项（option）后面出现了冒号（":"），则表示这个选项后面可以接参数（即一段描述信息DESCPRITION）

VARIABLE：表示将某个选项保存在变量VARIABLE中

当optstring以”:”开头时，getopts会区分invalid option错误和miss option argument错误。

```shell
while getopts "a:b:c:def" opt
do
  case $opt in
    a)
      echo echoa
      echo $opt
      echo $OPTARG;;
    b)
      echo echob;;
    c)
      echo echoc;;
    e)
      echo eeeee;;
    ?)
      echo unknow;;
  esac
done
```

应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用getopt

```sh
#!/bin/bash
#echo $@
#-o或--options选项后面接可接受的短选项，如ab:c::，表示可接受的短选项为-a -b -c，其中-a选项不接参数，-b选项后必须接参数，-c选项的参数为可选的
#-l或--longoptions选项后面接可接受的长选项，用逗号分开，冒号的意义同短选项。
#-n选项后接选项解析错误时提示的脚本名字
#!/bin/bash
ARGS=`getopt --options ab:c:: --longoptions along,blong:,clong:: -n "dongzw test.sh error" -- "$@"`
if [ $? != 0 ]; then
    echo "error in args"
    exit 1
fi
echo $ARGS
# ./test.sh -a -b bb -c --along --blong bblong --clong
# 输出结果为：-a -b 'bb' -c '' --along --blong 'bblong' --clong '' --

#将规范化后的命令行参数分配至位置参数（$1,$2,...)
eval set -- "${ARGS}"  #  The  args  are read and concatenated together into a single command
while true
do
    case "$1" in
        -a|--along) 
            echo "Option a";
            shift
            ;;
        -b|--blong)
            echo "Option b, argument $2";
            shift 2
            ;;
        -c|--clong)
            case "$2" in
                "")
                    echo "Option c, no argument";
                    shift 2  
                    ;;
                *)
                    echo "Option c, argument $2";
                    shift 2;
                    ;;
            esac
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Internal error!"
            exit 1
            ;;
    esac
done
#处理剩余的参数
for arg in $@
do
    echo "processing $arg"
done
```







nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。**

nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。

```
 nohup Command [ Arg … ] [　& ]
```

> Command：要执行的命令。
> Arg：一些参数，可以指定输出文件。
> &：让命令在后台执行，终端退出后命令仍旧执行。

```
nohup /root/runoob.sh > runoob.log 2>&1 &
```

> 2>&1 解释：
>
> 将标准错误 2 重定向到标准输出 &1 ，标准输出 &1 再被重定向输入到 runoob.log 文件中。
>
> - 0 – stdin (standard input，标准输入)
> - 1 – stdout (standard output，标准输出)
> - 2 – stderr (standard error，标准错误输出)



```sh
export [-fnp][变量名称]=[变量设置值]
```

其中：

- -f 　代表[变量名称]中为函数名称。
- -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
- -p 　列出所有的shell赋予程序的环境变量。



# Scratch

## sh

```sh
#!/bin/bash
# 作者：董志伟
# 2021/8/27 从第一个脚本开始牛逼起来。

setup_base_environ() {
	ping -c 1 114.114.114.114 > /dev/null 2>&1	
	if [ $? != 0 ]; then		
        echo "network error"		
        exit 1;	
	fi
	
	echo "setup base environ"
    mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
    wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
    yum clean all
    yum makecache
    # build essentials
    yum -y groupinstall "Development Tools" "Development Libraries"
    yum install -y net-tools
    yum install -y kernel-devel
    
    echo "installing Java"
    yum install java-1.8.0-openjdk-devel.x86_64
    cat << EOF >> /etc/profile
    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el6_9.x86_64
    export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    export PATH=$PATH:$JAVA_HOME/bin
    EOF
    
    source /etc/profile
    java -version > /dev/null
    if [ $? != 0 ]; then
        echo "java installed failed"
        exit;
    fi
    echo "installing Python"
    yum -y install python3
    yum –y install python3-pip

    mkdir ~/.pip
    cat << EOF > ~/.pip/pip.conf
    [global]
    index-url = https://pypi.tuna.tsinghua.edu.cn/simple
    [install]
    trusted-host = pypi.tuna.tsinghua.edu.cn
    EOF
    echo "setup_base_environ ok"
}

setup_tmux_vim() {
	# tmux & vim 
    echo "setup tmux & vim"
    yum install -y libevent-devel ncurses-devel
    TMUX_URL=https://github.com/tmux/tmux/releases/download/3.2/tmux-3.2.tar.gz
    TARGZ_NAME=`echo $TMUX_URL | awk -F/ '{print $NF}'` # 获取awk的最后一个元素
    wget $TMUX_URL -O /opt/$TARGZ_NAME
    TMUX_NAME=`echo $TMUX_NAME | awk -F '.tar.gz' '{print $1}'`
    tar /opt/$TMUX_NAME -xvf -C /opt/
    cd /opt/TMUX_NAME
    ./configure
    make && sudo make install
    yum install -y vim  
    wget https://raw.githubusercontent.com/dongzwhitsz/Tools/main/.vimrc -O ~/.vimrc
    echo "setup_tmux_vim ok"
}

setup_mysql() {
	echo "setup mysql"
	items=`rpm -qa |grep -i mysql`
	# 如果系统中已经装过了mysql
	if [ ${items[@]} != 0 ]; then
        echo "uninstalling old mysql"
        for i in $items; do 
          yum -y remove $i
        done
        rm -rf /etc/my.cnf
        rm -rf /var/log/mysqld.log
	fi
    wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
    rpm -ivh mysql-community-release-el7-5.noarch.rpm
    rm -rf mysql-community-release-el7-5.noarch.rpm
    yum update
    yum -y install mysql-server
    chown -R mysql:mysql /var/lib/mysql
    systemctl start mysqld
    mysqladmin -u root -pdongzhiwei 
    mysql -u root -pdongzhiwei -e "grant all privileges on *.* to 'root'@'%' identified by 'dongzhiwei' with grant option;flush privileges;"
    firewall-cmd --permanent --add-service=mysql  #永久开放mysql
    # firewall-cmd --zone=public --add-port=3306/tcp --permanent  #在public中永久开放3306端口
    firewall-cmd reload
    echo "setup_mysql ok"
}

setup_redis() {
	# redis配置参考link：https://www.cnblogs.com/stulzq/p/9288401.html
	REDIS_URL=http://download.redis.io/releases/redis-6.0.9.tar.gz
	TARGZ_NAME=`echo $REDIS_URL | awk -F/ '{print $NF}'`
	REDIS_NAME=`echo $TARGZ_NAME | awk -F '.tar.gz' '{print $1}'`
    wget $REDIS_URL -O /opt/$TARGZ_NAME
    tar /opt/$TARGZ_NAME -xvf -C /opt/
    make & make install PRIFIX=/opt/redis
    mkdir /opt/redis/etc
    cp /opt/$REDIS_NAME/redis.cnf /opt/redis/etc/
    # sed daemon no ==> yes
    sed -i "s/daemon no/daemon yes/g" /opt/redis/etc/redis.cnf
    firewall-cmd --permanent --add-service=redis  #永久开放redis
    firewall-cmd reload
    echo "setup_redis ok"
}

setup_zookeeper() {
	ZOOKEEPER_URL=https://dlcdn.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz
	TARGZ_NAME=`echo $ZOOKEEPER_URL | awk -F/ '{print $NF}'`
	ZOOKEEPRE_NAME=`echo $TARGZ_NAME | awk -F '-bin.tar.gz' '{print $1}'`
	wget $ZOOKEEPER_URL -O /opt/$TARGZ_NAME
	tar /opt/$TARGZ_NAME -xvf -C /opt/
	mkdir /opt/$ZOOKEEPRE_NAME/data
	mkdir /opt/$ZOOKEEPRE_NAME/logs
	cat << EOF > conf/zoo.cfg
    tickTime = 2000
    dataDir = /opt/zookeeper-3.7.0/data
    dataLogDir = /opt/zookeeper-3.7.0/logs
    clientPort = 2181
    initLimit = 5
    syncLimit = 2
    EOF
    firewall-cmd --permanent --add-service=zookeeper
    firewall-cmd reload
    echo "setup_zookeeper ok"
}

setup_nacos() {
	NACOS_URL=https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.tar.gz 
	curl $NACOS_URL -O /opt/nacos-server-2.0.3.tar.gz
  tar -xvf /opt/nacos-server-2.0.3.tar.gz  -C /opt/
	cd /opt/nacos-server-2.0.3
	echo "setup_nacos ok"
}



# setup_base_environ
# setup_tmux_vim
# setup_mysql
# setup_redis
case $1 in
	base)
		setup_base_environ;;
	input)
		setup_tmux_vim;;
	mysql)
		setup_mysql;;
	redis)
		setup_redis;;
        ?)
        echo "Unknown parameter"
        exit 1;;
esac
```





### setup_my_centos_7_environ.sh

```shell
#!/bin/bash
# 作者：董志伟
# 2021/8/27 从第一个脚本开始牛逼起来。
set -x

setup_base_environ() {
	ping -c 1 114.114.114.114 > /dev/null 2>&1	
	if [ $? != 0 ]; then		
        echo "network error"		
        exit 1;	
	fi
	
	echo "setup base environ"
  mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
  wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
  yum clean all
  yum -y update
  yum makecache
  # build essentials
  yum -y groupinstall "Development Tools" "Development Libraries"
  yum install -y epel-release
  # upgrade gcc
  yum -y install centos-release-scl
  yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
  scl enable devtoolset-9 bash

  yum -y install tcl > /dev/null
  yum install -y net-tools
  yum install -y kernel-devel

  yum install -y vsftpd # 安装sftp、ftp服务
  systemctl enable vsftpd
  systemctl start vsftpd

  echo "installing Java"
  OLD_JDK=`rpm -qa | grep java | grep openjdk`
  for item in $OLD_JDK; do
    rpm -e --nodeps $item
  done

  JDK_URL=https://d6.injdk.cn/openjdk/adoptopenjdk/8/openj9/OpenJDK8U-jdk_x64_linux_openj9_8u262b10_openj9-0.21.0.tar.gz
  TARGZ_NAME=`echo $JDK_URL | awk -F/ '{print $NF}'`
  JDK_NAME='jdk8u262-b10'
  wget -O $JDK_URL /opt/$TARGZ_NAME
  tar -xf $TARGZ_NAME -C /opt
  JAVA_HOME=/opt/$JDK_NAME
  JRE_HOME=$JAVA_HOME/jre
  cat << EOF >> /etc/profile
export JAVA_HOME=$JAVA_HOME
export JRE_HOME=$JRE_HOME
export CLASSPATH=.:\$JAVA_HOME/jre/lib/rt.jar:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar
export PATH=\$PATH:\$JAVA_HOME/bin:/usr/local/bin
EOF
  source /etc/profile
  java -version > /dev/null
  if [ $? != 0 ]; then
      echo "java installed failed"
      exit;
  fi

  MAVEN_URL=https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.2/binaries/apache-maven-3.8.2-bin.tar.gz
  
  TARGZ_NAME=`echo $MAVEN_URL | awk -F/ '{print $NF}'`
  MAVEN_NAME=`echo $TARGZ_NAME | awk -F '-bin.tar.gz' '{print $1}'`
  wget $MAVEN_URL -O /opt/$TARGZ_NAME
  tar -xf /opt/$TARGZ_NAME -C /opt
  MAVEN_HOME=/opt/$MAVEN_NAME
  cat << EOF >> /etc/profile
export MAVEN_HOME=$MAVEN_HOME
export PATH=\$PATH:\$MAVEN_HOME\bin
EOF
  sed -i '/<mirrors>/a\
    <mirror>\
      <id>aliyunmaven</id>\
      <mirrorOf>*</mirrorOf>\
      <name>阿里云公共仓库</name>\
      <url>https://maven.aliyun.com/repository/public</url>\
    </mirror>' $MAVEN_HOME/conf/settings.xml

  echo "installing Python"
  yum -y install python3
  yum –y install python3-pip

  mkdir ~/.pip
  cat << EOF > ~/.pip/pip.conf
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host = pypi.tuna.tsinghua.edu.cn
EOF
    echo "setup_base_environ ok"
}

setup_tmux_vim() {
	# tmux & vim 
  echo "setup tmux & vim"
  yum install -y libevent-devel ncurses-devel
  TMUX_URL=https://gitee.com/dvge/Tools/raw/master/tmux-3.2.tar.gz
  TARGZ_NAME=`echo $TMUX_URL | awk -F/ '{print $NF}'` # 获取awk的最后一个元素
  wget $TMUX_URL -O /opt/$TARGZ_NAME
  if [ $? != 0 ]; then
    echo "wget tmux error!"
    exit 1;
  fi
  TMUX_NAME=`echo $TARGZ_NAME | awk -F '.tar.gz' '{print $1}'`
  tar -xvf /opt/$TARGZ_NAME -C /opt/
  cd /opt/$TMUX_NAME
  ./configure
  make
  make install
  if [ $? != 0 ]; then
    echo "tmux make install error!"
    exit 2;
  fi
  yum install -y vim
  wget https://gitee.com/dvge/Tools/raw/master/vimrc.txt -O /home/dongzw/.vimrc
  if [ $? != 0]; then
    echo "wget vimrc error"
    exit 1;
  fi
  echo "setup_tmux_vim ok"
}

setup_mysql() {
	echo "setup mysql"
	items=`rpm -qa |grep -i mysql`
	# 如果系统中已经装过了mysql
	if [ ${#items[@]} != 0 ]; then
        echo "uninstalling old mysql"
        for i in $items; do 
          yum -y remove $i
          if [ $? != 0 ]; then
            echo "yum remove $i error!"
            exit 2
          fi
        done
        rm -rf /etc/my.cnf
        rm -rf /var/log/mysqld.log
	fi
  wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
  if [ $? != 0 ]; then
    echo "wget mysql community error"
    exit 1
  fi
  rpm -ivh mysql-community-release-el7-5.noarch.rpm
  rm -rf mysql-community-release-el7-5.noarch.rpm
  yum -y update
  yum -y install mysql-server
  chown -R mysql:mysql /var/lib/mysql
  systemctl start mysqld
  mysqladmin -u root password dongzhiwei 
  mysql -u root -pdongzhiwei -e "grant all privileges on *.* to 'root'@'%' identified by 'dongzhiwei' with grant option;flush privileges;"
  firewall-cmd --permanent --add-service=mysql  #永久开放mysql
  # firewall-cmd --zone=public --add-port=3306/tcp --permanent  #在public中永久开放3306端口
  firewall-cmd --reload
  echo "setup_mysql ok"
}

setup_redis() {
	# redis配置参考link：https://www.cnblogs.com/stulzq/p/9288401.html
	REDIS_URL=http://download.redis.io/releases/redis-6.0.9.tar.gz
	TARGZ_NAME=`echo $REDIS_URL | awk -F/ '{print $NF}'`
	REDIS_NAME=`echo $TARGZ_NAME | awk -F '.tar.gz' '{print $1}'`
  wget $REDIS_URL -O /opt/$TARGZ_NAME > /dev/null
  if [ $? != 0 ]; then
    echo "wget redis error"
    exit
  fi
  tar -xf /opt/$TARGZ_NAME -C /opt/
  cd /opt/$REDIS_NAME
  make > /dev/null
  make install PREFIX=/opt/redis > /dev/null
  if [ $? != 0 ]; then
    echo "make install redis error"
    exit 2
  fi;
  mkdir /opt/redis/etc
  cp /opt/$REDIS_NAME/redis.conf /opt/redis/etc/
  # sed daemon no ==> yes
  sed -i "s/daemonize no/daemonize yes/g" /opt/redis/etc/redis.conf
  sed -i "s/bind 127.0.0.1/# &/g" /opt/redis/etc/redis.conf
  sed -i "s/protected-mode yes/protected-mode no/g" /opt/redis/etc/redis.conf
  sed -i "s/# requirepass foobared/requirepass dongzhiwei/g" /opt/redis/etc/redis.conf
  firewall-cmd --permanent --add-service=redis  #永久开放redis
  firewall-cmd --reload
  echo "setup_redis ok"
}

start_redis() {
  /opt/redis/bin/redis-server /opt/redis/etc/redis.conf
  if [ $? != 0 ]; then
    echo "start redis error"
  fi
}

setup_zookeeper() {
	ZOOKEEPER_URL=https://dlcdn.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz
	TARGZ_NAME=`echo $ZOOKEEPER_URL | awk -F/ '{print $NF}'`
	ZOOKEEPRE_NAME=`echo $TARGZ_NAME | awk -F '-bin.tar.gz' '{print $1}'`
	wget $ZOOKEEPER_URL -O /opt/$TARGZ_NAME
	tar -xvf /opt/$TARGZ_NAME -C /opt/
	mkdir /opt/$ZOOKEEPRE_NAME/data
	mkdir /opt/$ZOOKEEPRE_NAME/logs
	cat << EOF > conf/zoo.cfg
tickTime = 2000
dataDir = /opt/zookeeper-3.7.0/data
dataLogDir = /opt/zookeeper-3.7.0/logs
clientPort = 2181
initLimit = 5
syncLimit = 2
EOF
    firewall-cmd --permanent --add-service=zookeeper
    firewall-cmd --reload
    echo "setup_zookeeper ok"
}

setup_es() {
  # https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.14.0-linux-x86_64.tar.gz
  ES_URL=https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.14.0-x86_64.rpm
  RPM_NAME=`echo $ES_URL | awk -F/ '{print $NF}'`
  ES_NAME=`echo $ES_URL | awk -F/ '{print $NF}' | awk -F '-x86_64.rpm' '{print $1}'`
  wget $ES_URL -O /opt/$RPM_NAME
  rpm -ih /opt/$RPM_NAME
  if [ $? != 0 ]; then
    echo "es installed error"
  fi
  systemctl daemon-reload
  systemctl enable elasticsearch.service
  systemctl start elasticsearch.service
  # 配置文件位置：/etc/elasticsearch
  cat << EOF >> /etc/elasticsearch/jvm.options
-Xms512m
-Xmx512m
EOF
  cat << EOF >> /etc/elasticsearch/elasticsearch.yml
network.host: 0.0.0
bootstrap.system_call_filter: false
cluster.initial_master_nodes: ["node-1"]
EOF
}

setup_nacos() {
	NACOS_URL=https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.tar.gz 
	curl $NACOS_URL -O /opt/nacos-server-2.0.3.tar.gz
  tar -xvf /opt/nacos-server-2.0.3.tar.gz -C /opt/
	cd /opt/nacos-server-2.0.3
	echo "setup_nacos ok"
}

setup_rocketmq() {
  ROCKETMQ_URL=https://codeload.github.com/apache/rocketmq/tar.gz/refs/tags/rocketmq-all-4.9.1
  TARGZ_NAME=rocketmq-rocketmq-all-4.9.1.tar.gz
  ROCKETMQ_NAME=rocketmq-rocketmq-all-4.9.1
  wget $ROCKETMQ_URL -O /opt/$TARGZ_NAME
  tar -xf /opt/$TARGZ_NAME -C /opt
  cd /opt/$ROCKETMQ_NAME
  mvn -Prelease-all -DskipTests clean install -U
  # nohup sh bin/mqbroker -n localhost:9876 &
  # tail -f ~/logs/rocketmqlogs/broker.log
}

#
#setup_kafka() {
#}

#
#my_server_start() {
#}
#
#my_server_stop() {
#}
#
#my_server_status() {
#}


servers=(mysql redis)

# setup_base_environ
# setup_tmux_vim
# setup_mysql
# setup_redis
case $1 in
	base)
		setup_base_environ
    ;;
	input)
		setup_tmux_vim
    ;;
	mysql)
		setup_mysql
    ;;
	redis)
		setup_redis
    ;;
  initial)
    setup_base_environ
    setup_tmux_vim
    setup_mysql
    setup_redis
    ;;
  *)
    echo "Unknown parameter"
    exit 1
    ;;
esac




```



### rocketmq.runbroker.sh

```shell

#===========================================================================================
# Java Environment Setting
#===========================================================================================
error_exit ()
{
    echo "ERROR: $1 !!"
    exit 1
}

[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=$HOME/jdk/java
[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/usr/java
[ ! -e "$JAVA_HOME/bin/java" ] && error_exit "Please set the JAVA_HOME variable in your environment, We need java(x64)!"

export JAVA_HOME
export JAVA="$JAVA_HOME/bin/java"
export BASE_DIR=$(dirname $0)/..
export CLASSPATH=.:${BASE_DIR}/conf:${CLASSPATH}

#===========================================================================================
# JVM Configuration
#===========================================================================================
# The RAMDisk initializing size in MB on Darwin OS for gc-log
DIR_SIZE_IN_MB=600

choose_gc_log_directory()
{
    case "`uname`" in
        Darwin)
            if [ ! -d "/Volumes/RAMDisk" ]; then
                # create ram disk on Darwin systems as gc-log directory
                DEV=`hdiutil attach -nomount ram://$((2 * 1024 * DIR_SIZE_IN_MB))` > /dev/null
                diskutil eraseVolume HFS+ RAMDisk ${DEV} > /dev/null
                echo "Create RAMDisk /Volumes/RAMDisk for gc logging on Darwin OS."
            fi
            GC_LOG_DIR="/Volumes/RAMDisk"
        ;;
        *)
            # check if /dev/shm exists on other systems
            if [ -d "/dev/shm" ]; then
                GC_LOG_DIR="/dev/shm"
            else
                GC_LOG_DIR=${BASE_DIR}
            fi
        ;;
    esac
}

choose_gc_log_directory

JAVA_OPT="${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn125m"
JAVA_OPT="${JAVA_OPT} -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0"
JAVA_OPT="${JAVA_OPT} -verbose:gc -Xloggc:${GC_LOG_DIR}/rmq_broker_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy"
JAVA_OPT="${JAVA_OPT} -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m"
JAVA_OPT="${JAVA_OPT} -XX:-OmitStackTraceInFastThrow"
JAVA_OPT="${JAVA_OPT} -XX:+AlwaysPreTouch"
JAVA_OPT="${JAVA_OPT} -XX:MaxDirectMemorySize=15g"
JAVA_OPT="${JAVA_OPT} -XX:-UseLargePages -XX:-UseBiasedLocking"
JAVA_OPT="${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${BASE_DIR}/lib:${JAVA_HOME}/lib/ext"
#JAVA_OPT="${JAVA_OPT} -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n"
JAVA_OPT="${JAVA_OPT} ${JAVA_OPT_EXT}"
JAVA_OPT="${JAVA_OPT} -cp ${CLASSPATH}"

numactl --interleave=all pwd > /dev/null 2>&1
if [ $? -eq 0 ]
then
	if [ -z "$RMQ_NUMA_NODE" ] ; then
		numactl --interleave=all $JAVA ${JAVA_OPT} $@
	else
		numactl --cpunodebind=$RMQ_NUMA_NODE --membind=$RMQ_NUMA_NODE $JAVA ${JAVA_OPT} $@
	fi
else
	$JAVA ${JAVA_OPT} $@
fi
```

### docker_setup_my_environs.sh

```shell

start_my_redis() {
    echo "start my redis"
    docker ps | grep myredis > /dev/null
    if [ 0 == $? ]; then
        docker stop myredis
    fi
    docker container ls -a | grep myredis
    if [ 0 == $? ]; then
        docker container rm myredis
    fi
    HOST_WORK_DIR=/home/dongzw/Documents/redis
    docker images | grep redis | grep latest > /dev/null
    if [ ! 0 == $? ]; then
        echo "downloading redis:latest"
        docker pull redis:latest
    fi
    # 配置远程登陆
    # bind 0.0.0.0
    # protected-mode no

    docker run \
            -d \
            --name myredis \
            -p 6379:6379 \
            -v $HOST_WORK_DIR/data:/data\
            -v $HOST_WORK_DIR/conf:/etc/redis\
            redis \
            redis-server /etc/redis/redis.conf
    # 进入docker： docker exec -it myredis /bin/bash
}

while getopts "ihs:" opt
do
    case $opt in            
        h)
            echo "[-h] help"
            echo "[-s] server: (redis mysql)"
            ;;
        s)
            case $OPTARG in
                redis)
                    echo "start my redis server"
                    start_my_redis
                    ;;
                mysql)
                    echo "mysql ok"
                    ;;
                *)
                    echo "$OPTARG not supported"
                    ;;
            esac;;            
        ?)
            echo "error !!"
            ;;
    esac
done
```

### get_docker.sh

```sh
#!/bin/sh
set -e
# Docker CE for Linux installation script
#
# See https://docs.docker.com/engine/install/ for the installation steps.
#
# This script is meant for quick & easy install via:
#   $ curl -fsSL https://get.docker.com -o get-docker.sh
#   $ sh get-docker.sh
#
# For test builds (ie. release candidates):
#   $ curl -fsSL https://test.docker.com -o test-docker.sh
#   $ sh test-docker.sh
#
# NOTE: Make sure to verify the contents of the script
#       you downloaded matches the contents of install.sh
#       located at https://github.com/docker/docker-install
#       before executing.
#
# Git commit from https://github.com/docker/docker-install when
# the script was uploaded (Should only be modified by upload job):
SCRIPT_COMMIT_SHA="93d2499759296ac1f9c510605fef85052a2c32be"

# strip "v" prefix if present
VERSION="${VERSION#v}"

# The channel to install from:
#   * nightly
#   * test
#   * stable
#   * edge (deprecated)
DEFAULT_CHANNEL_VALUE="stable"
if [ -z "$CHANNEL" ]; then
	CHANNEL=$DEFAULT_CHANNEL_VALUE
fi

DEFAULT_DOWNLOAD_URL="https://download.docker.com"
if [ -z "$DOWNLOAD_URL" ]; then
	DOWNLOAD_URL=$DEFAULT_DOWNLOAD_URL
fi

DEFAULT_REPO_FILE="docker-ce.repo"
if [ -z "$REPO_FILE" ]; then
	REPO_FILE="$DEFAULT_REPO_FILE"
fi

mirror=''
DRY_RUN=${DRY_RUN:-}
while [ $# -gt 0 ]; do
	case "$1" in
		--mirror)
			mirror="$2"
			shift
			;;
		--dry-run)
			DRY_RUN=1
			;;
		--*)
			echo "Illegal option $1"
			;;
	esac
	shift $(( $# > 0 ? 1 : 0 ))
done

case "$mirror" in
	Aliyun)
		DOWNLOAD_URL="https://mirrors.aliyun.com/docker-ce"
		;;
	AzureChinaCloud)
		DOWNLOAD_URL="https://mirror.azure.cn/docker-ce"
		;;
esac

command_exists() {
	command -v "$@" > /dev/null 2>&1
}

# version_gte checks if the version specified in $VERSION is at least
# the given CalVer (YY.MM) version. returns 0 (success) if $VERSION is either
# unset (=latest) or newer or equal than the specified version. Returns 1 (fail)
# otherwise.
#
# examples:
#
# VERSION=20.10
# version_gte 20.10 // 0 (success)
# version_gte 19.03 // 0 (success)
# version_gte 21.10 // 1 (fail)
version_gte() {
	if [ -z "$VERSION" ]; then
			return 0
	fi
	eval calver_compare "$VERSION" "$1"
}

# calver_compare compares two CalVer (YY.MM) version strings. returns 0 (success)
# if version A is newer or equal than version B, or 1 (fail) otherwise. Patch
# releases and pre-release (-alpha/-beta) are not taken into account
#
# examples:
#
# calver_compare 20.10 19.03 // 0 (success)
# calver_compare 20.10 20.10 // 0 (success)
# calver_compare 19.03 20.10 // 1 (fail)
calver_compare() (
	set +x

	yy_a="$(echo "$1" | cut -d'.' -f1)"
	yy_b="$(echo "$2" | cut -d'.' -f1)"
	if [ "$yy_a" -lt "$yy_b" ]; then
		return 1
	fi
	if [ "$yy_a" -gt "$yy_b" ]; then
		return 0
	fi
	mm_a="$(echo "$1" | cut -d'.' -f2)"
	mm_b="$(echo "$2" | cut -d'.' -f2)"
	if [ "${mm_a#0}" -lt "${mm_b#0}" ]; then
		return 1
	fi

	return 0
)

is_dry_run() {
	if [ -z "$DRY_RUN" ]; then
		return 1
	else
		return 0
	fi
}

is_wsl() {
	case "$(uname -r)" in
	*microsoft* ) true ;; # WSL 2
	*Microsoft* ) true ;; # WSL 1
	* ) false;;
	esac
}

is_darwin() {
	case "$(uname -s)" in
	*darwin* ) true ;;
	*Darwin* ) true ;;
	* ) false;;
	esac
}

deprecation_notice() {
	distro=$1
	distro_version=$2
	echo
	printf "\033[91;1mDEPRECATION WARNING\033[0m\n"
	printf "    This Linux distribution (\033[1m%s %s\033[0m) reached end-of-life and is no longer supported by this script.\n" "$distro" "$distro_version"
	echo   "    No updates or security fixes will be released for this distribution, and users are recommended"
	echo   "    to upgrade to a currently maintained version of $distro."
	echo
	printf   "Press \033[1mCtrl+C\033[0m now to abort this script, or wait for the installation to continue."
	echo
	sleep 10
}

get_distribution() {
	lsb_dist=""
	# Every system that we officially support has /etc/os-release
	if [ -r /etc/os-release ]; then
		lsb_dist="$(. /etc/os-release && echo "$ID")"
	fi
	# Returning an empty string here should be alright since the
	# case statements don't act unless you provide an actual value
	echo "$lsb_dist"
}

echo_docker_as_nonroot() {
	if is_dry_run; then
		return
	fi
	if command_exists docker && [ -e /var/run/docker.sock ]; then
		(
			set -x
			$sh_c 'docker version'
		) || true
	fi

	# intentionally mixed spaces and tabs here -- tabs are stripped by "<<-EOF", spaces are kept in the output
	echo
	echo "================================================================================"
	echo
	if version_gte "20.10"; then
		echo "To run Docker as a non-privileged user, consider setting up the"
		echo "Docker daemon in rootless mode for your user:"
		echo
		echo "    dockerd-rootless-setuptool.sh install"
		echo
		echo "Visit https://docs.docker.com/go/rootless/ to learn about rootless mode."
		echo
	fi
	echo
	echo "To run the Docker daemon as a fully privileged service, but granting non-root"
	echo "users access, refer to https://docs.docker.com/go/daemon-access/"
	echo
	echo "WARNING: Access to the remote API on a privileged Docker daemon is equivalent"
	echo "         to root access on the host. Refer to the 'Docker daemon attack surface'"
	echo "         documentation for details: https://docs.docker.com/go/attack-surface/"
	echo
	echo "================================================================================"
	echo
}

# Check if this is a forked Linux distro
check_forked() {

	# Check for lsb_release command existence, it usually exists in forked distros
	if command_exists lsb_release; then
		# Check if the `-u` option is supported
		set +e
		lsb_release -a -u > /dev/null 2>&1
		lsb_release_exit_code=$?
		set -e

		# Check if the command has exited successfully, it means we're in a forked distro
		if [ "$lsb_release_exit_code" = "0" ]; then
			# Print info about current distro
			cat <<-EOF
			You're using '$lsb_dist' version '$dist_version'.
			EOF

			# Get the upstream release info
			lsb_dist=$(lsb_release -a -u 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut -d ':' -f 2 | tr -d '[:space:]')
			dist_version=$(lsb_release -a -u 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'codename' | cut -d ':' -f 2 | tr -d '[:space:]')

			# Print info about upstream distro
			cat <<-EOF
			Upstream release is '$lsb_dist' version '$dist_version'.
			EOF
		else
			if [ -r /etc/debian_version ] && [ "$lsb_dist" != "ubuntu" ] && [ "$lsb_dist" != "raspbian" ]; then
				if [ "$lsb_dist" = "osmc" ]; then
					# OSMC runs Raspbian
					lsb_dist=raspbian
				else
					# We're Debian and don't even know it!
					lsb_dist=debian
				fi
				dist_version="$(sed 's/\/.*//' /etc/debian_version | sed 's/\..*//')"
				case "$dist_version" in
					11)
						dist_version="bullseye"
					;;
					10)
						dist_version="buster"
					;;
					9)
						dist_version="stretch"
					;;
					8)
						dist_version="jessie"
					;;
				esac
			fi
		fi
	fi
}

do_install() {
	echo "# Executing docker install script, commit: $SCRIPT_COMMIT_SHA"

	if command_exists docker; then
		cat >&2 <<-'EOF'
			Warning: the "docker" command appears to already exist on this system.

			If you already have Docker installed, this script can cause trouble, which is
			why we're displaying this warning and provide the opportunity to cancel the
			installation.

			If you installed the current Docker package using this script and are using it
			again to update Docker, you can safely ignore this message.

			You may press Ctrl+C now to abort this script.
		EOF
		( set -x; sleep 20 )
	fi

	user="$(id -un 2>/dev/null || true)"

	sh_c='sh -c'
	if [ "$user" != 'root' ]; then
		if command_exists sudo; then
			sh_c='sudo -E sh -c'
		elif command_exists su; then
			sh_c='su -c'
		else
			cat >&2 <<-'EOF'
			Error: this installer needs the ability to run commands as root.
			We are unable to find either "sudo" or "su" available to make this happen.
			EOF
			exit 1
		fi
	fi

	if is_dry_run; then
		sh_c="echo"
	fi

	# perform some very rudimentary platform detection
	lsb_dist=$( get_distribution )
	lsb_dist="$(echo "$lsb_dist" | tr '[:upper:]' '[:lower:]')"

	if is_wsl; then
		echo
		echo "WSL DETECTED: We recommend using Docker Desktop for Windows."
		echo "Please get Docker Desktop from https://www.docker.com/products/docker-desktop"
		echo
		cat >&2 <<-'EOF'

			You may press Ctrl+C now to abort this script.
		EOF
		( set -x; sleep 20 )
	fi

	case "$lsb_dist" in

		ubuntu)
			if command_exists lsb_release; then
				dist_version="$(lsb_release --codename | cut -f2)"
			fi
			if [ -z "$dist_version" ] && [ -r /etc/lsb-release ]; then
				dist_version="$(. /etc/lsb-release && echo "$DISTRIB_CODENAME")"
			fi
		;;

		debian|raspbian)
			dist_version="$(sed 's/\/.*//' /etc/debian_version | sed 's/\..*//')"
			case "$dist_version" in
				11)
					dist_version="bullseye"
				;;
				10)
					dist_version="buster"
				;;
				9)
					dist_version="stretch"
				;;
				8)
					dist_version="jessie"
				;;
			esac
		;;

		centos|rhel|sles)
			if [ -z "$dist_version" ] && [ -r /etc/os-release ]; then
				dist_version="$(. /etc/os-release && echo "$VERSION_ID")"
			fi
		;;

		*)
			if command_exists lsb_release; then
				dist_version="$(lsb_release --release | cut -f2)"
			fi
			if [ -z "$dist_version" ] && [ -r /etc/os-release ]; then
				dist_version="$(. /etc/os-release && echo "$VERSION_ID")"
			fi
		;;

	esac

	# Check if this is a forked Linux distro
	check_forked

	# Print deprecation warnings for distro versions that recently reached EOL,
	# but may still be commonly used (especially LTS versions).
	case "$lsb_dist.$dist_version" in
		debian.stretch|debian.jessie)
			deprecation_notice "$lsb_dist" "$dist_version"
			;;
		raspbian.stretch|raspbian.jessie)
			deprecation_notice "$lsb_dist" "$dist_version"
			;;
		ubuntu.xenial|ubuntu.trusty)
			deprecation_notice "$lsb_dist" "$dist_version"
			;;
		fedora.*)
			if [ "$dist_version" -lt 33 ]; then
				deprecation_notice "$lsb_dist" "$dist_version"
			fi
			;;
	esac

	# Run setup for each distro accordingly
	case "$lsb_dist" in
		ubuntu|debian|raspbian)
			pre_reqs="apt-transport-https ca-certificates curl"
			if ! command -v gpg > /dev/null; then
				pre_reqs="$pre_reqs gnupg"
			fi
			apt_repo="deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] $DOWNLOAD_URL/linux/$lsb_dist $dist_version $CHANNEL"
			(
				if ! is_dry_run; then
					set -x
				fi
				$sh_c 'apt-get update -qq >/dev/null'
				$sh_c "DEBIAN_FRONTEND=noninteractive apt-get install -y -qq $pre_reqs >/dev/null"
				$sh_c "curl -fsSL \"$DOWNLOAD_URL/linux/$lsb_dist/gpg\" | gpg --dearmor --yes -o /usr/share/keyrings/docker-archive-keyring.gpg"
				$sh_c "echo \"$apt_repo\" > /etc/apt/sources.list.d/docker.list"
				$sh_c 'apt-get update -qq >/dev/null'
			)
			pkg_version=""
			if [ -n "$VERSION" ]; then
				if is_dry_run; then
					echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
				else
					# Will work for incomplete versions IE (17.12), but may not actually grab the "latest" if in the test channel
					pkg_pattern="$(echo "$VERSION" | sed "s/-ce-/~ce~.*/g" | sed "s/-/.*/g").*-0~$lsb_dist"
					search_command="apt-cache madison 'docker-ce' | grep '$pkg_pattern' | head -1 | awk '{\$1=\$1};1' | cut -d' ' -f 3"
					pkg_version="$($sh_c "$search_command")"
					echo "INFO: Searching repository for VERSION '$VERSION'"
					echo "INFO: $search_command"
					if [ -z "$pkg_version" ]; then
						echo
						echo "ERROR: '$VERSION' not found amongst apt-cache madison results"
						echo
						exit 1
					fi
					if version_gte "18.09"; then
							search_command="apt-cache madison 'docker-ce-cli' | grep '$pkg_pattern' | head -1 | awk '{\$1=\$1};1' | cut -d' ' -f 3"
							echo "INFO: $search_command"
							cli_pkg_version="=$($sh_c "$search_command")"
					fi
					pkg_version="=$pkg_version"
				fi
			fi
			(
				pkgs=""
				if version_gte "18.09"; then
						# older versions don't support a cli package
						pkgs="$pkgs docker-ce-cli${cli_pkg_version%=}"
				fi
				if version_gte "20.10" && [ "$(uname -m)" = "x86_64" ]; then
						# also install the latest version of the "docker scan" cli-plugin (only supported on x86 currently)
						pkgs="$pkgs docker-scan-plugin"
				fi
				pkgs="$pkgs docker-ce${pkg_version%=}"
				if ! is_dry_run; then
					set -x
				fi
				$sh_c "DEBIAN_FRONTEND=noninteractive apt-get install -y -qq --no-install-recommends $pkgs >/dev/null"
				if version_gte "20.10"; then
					# Install docker-ce-rootless-extras without "--no-install-recommends", so as to install slirp4netns when available
					$sh_c "DEBIAN_FRONTEND=noninteractive apt-get install -y -qq docker-ce-rootless-extras${pkg_version%=} >/dev/null"
				fi
			)
			echo_docker_as_nonroot
			exit 0
			;;
		centos|fedora|rhel)
			if [ "$(uname -m)" != "s390x" ] && [ "$lsb_dist" = "rhel" ]; then
				echo "Packages for RHEL are currently only available for s390x."
				exit 1
			fi
			yum_repo="$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE"
			if ! curl -Ifs "$yum_repo" > /dev/null; then
				echo "Error: Unable to curl repository file $yum_repo, is it valid?"
				exit 1
			fi
			if [ "$lsb_dist" = "fedora" ]; then
				pkg_manager="dnf"
				config_manager="dnf config-manager"
				enable_channel_flag="--set-enabled"
				disable_channel_flag="--set-disabled"
				pre_reqs="dnf-plugins-core"
				pkg_suffix="fc$dist_version"
			else
				pkg_manager="yum"
				config_manager="yum-config-manager"
				enable_channel_flag="--enable"
				disable_channel_flag="--disable"
				pre_reqs="yum-utils"
				pkg_suffix="el"
			fi
			(
				if ! is_dry_run; then
					set -x
				fi
				$sh_c "$pkg_manager install -y -q $pre_reqs"
				$sh_c "$config_manager --add-repo $yum_repo"

				if [ "$CHANNEL" != "stable" ]; then
					$sh_c "$config_manager $disable_channel_flag docker-ce-*"
					$sh_c "$config_manager $enable_channel_flag docker-ce-$CHANNEL"
				fi
				$sh_c "$pkg_manager makecache"
			)
			pkg_version=""
			if [ -n "$VERSION" ]; then
				if is_dry_run; then
					echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
				else
					pkg_pattern="$(echo "$VERSION" | sed "s/-ce-/\\\\.ce.*/g" | sed "s/-/.*/g").*$pkg_suffix"
					search_command="$pkg_manager list --showduplicates 'docker-ce' | grep '$pkg_pattern' | tail -1 | awk '{print \$2}'"
					pkg_version="$($sh_c "$search_command")"
					echo "INFO: Searching repository for VERSION '$VERSION'"
					echo "INFO: $search_command"
					if [ -z "$pkg_version" ]; then
						echo
						echo "ERROR: '$VERSION' not found amongst $pkg_manager list results"
						echo
						exit 1
					fi
					if version_gte "18.09"; then
						# older versions don't support a cli package
						search_command="$pkg_manager list --showduplicates 'docker-ce-cli' | grep '$pkg_pattern' | tail -1 | awk '{print \$2}'"
						cli_pkg_version="$($sh_c "$search_command" | cut -d':' -f 2)"
					fi
					# Cut out the epoch and prefix with a '-'
					pkg_version="-$(echo "$pkg_version" | cut -d':' -f 2)"
				fi
			fi
			(
				if ! is_dry_run; then
					set -x
				fi
				# install the correct cli version first
				if [ -n "$cli_pkg_version" ]; then
					$sh_c "$pkg_manager install -y -q docker-ce-cli-$cli_pkg_version"
				fi
				$sh_c "$pkg_manager install -y -q docker-ce$pkg_version"
				if version_gte "20.10"; then
					$sh_c "$pkg_manager install -y -q docker-ce-rootless-extras$pkg_version"
				fi
			)
			echo_docker_as_nonroot
			exit 0
			;;
		sles)
			if [ "$(uname -m)" != "s390x" ]; then
				echo "Packages for SLES are currently only available for s390x"
				exit 1
			fi

			sles_version="${dist_version##*.}"
			sles_repo="$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE"
			opensuse_repo="https://download.opensuse.org/repositories/security:SELinux/SLE_15_SP$sles_version/security:SELinux.repo"
			if ! curl -Ifs "$sles_repo" > /dev/null; then
				echo "Error: Unable to curl repository file $sles_repo, is it valid?"
				exit 1
			fi
			pre_reqs="ca-certificates curl libseccomp2 awk"
			(
				if ! is_dry_run; then
					set -x
				fi
				$sh_c "zypper install -y $pre_reqs"
				$sh_c "zypper addrepo $sles_repo"
				if ! is_dry_run; then
						cat >&2 <<-'EOF'
						WARNING!!
						openSUSE repository (https://download.opensuse.org/repositories/security:SELinux) will be enabled now.
						Do you wish to continue?
						You may press Ctrl+C now to abort this script.
						EOF
						( set -x; sleep 30 )
				fi
				$sh_c "zypper addrepo $opensuse_repo"
				$sh_c "zypper --gpg-auto-import-keys refresh"
				$sh_c "zypper lr -d"
			)
			pkg_version=""
			if [ -n "$VERSION" ]; then
				if is_dry_run; then
					echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
				else
					pkg_pattern="$(echo "$VERSION" | sed "s/-ce-/\\\\.ce.*/g" | sed "s/-/.*/g")"
					search_command="zypper search -s --match-exact 'docker-ce' | grep '$pkg_pattern' | tail -1 | awk '{print \$6}'"
					pkg_version="$($sh_c "$search_command")"
					echo "INFO: Searching repository for VERSION '$VERSION'"
					echo "INFO: $search_command"
					if [ -z "$pkg_version" ]; then
						echo
						echo "ERROR: '$VERSION' not found amongst zypper list results"
						echo
						exit 1
					fi
					search_command="zypper search -s --match-exact 'docker-ce-cli' | grep '$pkg_pattern' | tail -1 | awk '{print \$6}'"
					# It's okay for cli_pkg_version to be blank, since older versions don't support a cli package
					cli_pkg_version="$($sh_c "$search_command")"
					pkg_version="-$pkg_version"

					search_command="zypper search -s --match-exact 'docker-ce-rootless-extras' | grep '$pkg_pattern' | tail -1 | awk '{print \$6}'"
					rootless_pkg_version="$($sh_c "$search_command")"
					rootless_pkg_version="-$rootless_pkg_version"
				fi
			fi
			(
				if ! is_dry_run; then
					set -x
				fi
				# install the correct cli version first
				if [ -n "$cli_pkg_version" ]; then
					$sh_c "zypper install -y  docker-ce-cli-$cli_pkg_version"
				fi
				$sh_c "zypper install -y docker-ce$pkg_version"
				if version_gte "20.10"; then
					$sh_c "zypper install -y docker-ce-rootless-extras$rootless_pkg_version"
				fi
			)
			echo_docker_as_nonroot
			exit 0
			;;
		*)
			if [ -z "$lsb_dist" ]; then
				if is_darwin; then
					echo
					echo "ERROR: Unsupported operating system 'macOS'"
					echo "Please get Docker Desktop from https://www.docker.com/products/docker-desktop"
					echo
					exit 1
				fi
			fi
			echo
			echo "ERROR: Unsupported distribution '$lsb_dist'"
			echo
			exit 1
			;;
	esac
	exit 1
}

# wrapped up in a function so that we have some protection against only getting
# half the file during "curl | sh"
do_install
```



### ifup

```sh
#!/bin/bash
# Network Interface Configuration System
# Copyright (c) 1996-2009 Red Hat, Inc. all rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

unset WINDOW # defined by screen, conflicts with our usage

. /etc/init.d/functions

cd /etc/sysconfig/network-scripts
. ./network-functions

[ -f ../network ] && . ../network

CONFIG=${1}

[ -z "${CONFIG}" ] && {
    echo $"Usage: ifup <configuration>" >&2
    exit 1
}

need_config "${CONFIG}"

[ -f "${CONFIG}" ] || {
    echo $"$0: configuration for ${1} not found." >&2
    echo $"Usage: ifup <configuration>" >&2
    exit 1
}

if [ ${UID} != 0 ]; then
    if [ -x /usr/sbin/usernetctl ]; then
        source_config
        if /usr/sbin/usernetctl ${CONFIG} report ; then
            exec /usr/sbin/usernetctl ${CONFIG} up
        fi
    fi
    echo $"Users cannot control this device." >&2
    exit 1
fi

source_config

if [ "foo$2" = "fooboot" ] && [ "${ONBOOT}" = "no" -o "${ONBOOT}" = "NO" ]
then
    exit 0
fi
if [ -n "$IN_HOTPLUG" ] && [ "${HOTPLUG}" = "no" -o "${HOTPLUG}" = "NO" ]
then
    exit 0
fi
if [ -n "$IN_HOTPLUG" -a "${TYPE}" = "Bridge" ]; 
then
    exit 0
fi

if [ "$_use_nm" = "true" -a -n "$UUID" -a "$REALDEVICE" != "lo" ]; then
    if [ "foo$2" = "fooboot" ] && [ "${TYPE}" = "Wireless" ]; then
        exit 0
    fi
    [ -n "${DEVICE}" ] && is_nm_handling ${DEVICE} && exit 0
    nmcli con up uuid "$UUID"
    exit $?
fi

# Ethernet 802.1Q VLAN support
if [ "${VLAN}" = "yes" ] && [ "$ISALIAS" = "no" ] && [ -n "$DEVICE" ]; then
    if [ -n "${VID}" ]; then
        if test -z "$PHYSDEV"; then
            net_log $"PHYSDEV should be set for device ${DEVICE}"
            exit 1
        fi
    else
        VID=""
        MATCH='^.+\.[0-9]{1,4}$'
        if [[ "${DEVICE}" =~ $MATCH ]]; then
            VID=$(echo "${DEVICE}" | LC_ALL=C sed 's/^.*\.\([0-9]\+\)/\1/')
            PHYSDEV=${DEVICE%.*}
        fi
        MATCH='^vlan[0-9]{1,4}?'
        if [[ "${DEVICE}" =~ $MATCH ]]; then
            VID=$(echo "${DEVICE}" | LC_ALL=C sed 's/^vlan0*//')
            # PHYSDEV should be set in ifcfg-vlan* file
            if test -z "$PHYSDEV"; then
                net_log $"PHYSDEV should be set for device ${DEVICE}"
                exit 1
            fi
        fi
    fi
    if [ -n "$VID" ]; then
        if [ ! -d /proc/net/vlan ]; then
            if ! modprobe 8021q >/dev/null 2>&1 ; then
                net_log $"No 802.1Q VLAN support available in kernel for device ${DEVICE}"
                exit 1
            fi
        fi

        is_available_wait ${PHYSDEV} ${DEVTIMEOUT} || {
            if [ "$?" = "1" ] ; then
                net_log $"$alias device ${DEVICE} does not seem to be present, delaying initialization."
                exit 1
            else
                exit 0
            fi
        }

        # Link on Physical device needs to be up but no ip required
        check_device_down ${PHYSDEV} && { ip -o link set dev ${PHYSDEV} up; }

        if [ ! -f /proc/net/vlan/${DEVICE} ]; then
            if [ "${REORDER_HDR}" = "no" -o "${REORDER_HDR}" = "0" ]; then
                FLAG_REORDER_HDR="reorder_hdr off"
            fi

            if [ "${GVRP}" = "yes" -o "${GVRP}" = "1" ]; then
                FLAG_GVRP="gvrp on"
            fi

            ip link add dev ${DEVICE} link ${PHYSDEV} type vlan id ${VID} ${FLAG_REORDER_HDR} ${FLAG_GVRP} || {
                (/usr/bin/logger -p daemon.info -t ifup \
                     $"ERROR: could not add vlan ${VID} as ${DEVICE} on dev ${PHYSDEV}" &) &
                net_log $"ERROR: could not add vlan ${VID} as ${DEVICE} on dev ${PHYSDEV}"
                exit 1
            }

            [ -n "${VLAN_EGRESS_PRIORITY_MAP}" ] && ip link set ${DEVICE} type vlan egress ${VLAN_EGRESS_PRIORITY_MAP}
        fi
    fi

    /usr/lib/systemd/systemd-sysctl \
        --prefix "/proc/sys/net/ipv4/conf/${DEVICE}" \
        --prefix "/proc/sys/net/ipv6/conf/${DEVICE}"
fi

if [ "${BOOTPROTO}" = "bootp" -o "${BOOTPROTO}" = "dhcp" ]; then
    DYNCONFIG=true
fi

if [ -x /sbin/ifup-pre-local ]; then
    /sbin/ifup-pre-local ${CONFIG} $2
fi

OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-${DEVICETYPE}"

if [ ! -x ${OTHERSCRIPT} ]; then
    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-${TYPE}"
fi

if [ ! -x ${OTHERSCRIPT} ]; then
    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-eth"
fi

exec ${OTHERSCRIPT} ${CONFIG} $2

```



### ifdown

```shell
#!/bin/bash

unset WINDOW # defined by screen, conflicts with our usage

. /etc/init.d/functions

cd /etc/sysconfig/network-scripts
. ./network-functions

[ -f ../network ] && . ../network

CONFIG=$1

[ -z "$CONFIG" ] && {
    echo $"usage: ifdown <configuration>" >&2
    exit 1
}

need_config "${CONFIG}"

[ -f "$CONFIG" ] || {
    echo $"usage: ifdown <configuration>" >&2
    exit 1
}

if [ $UID != 0 ]; then
    if [ -x /usr/sbin/usernetctl ]; then
        source_config
        if /usr/sbin/usernetctl ${CONFIG} report ; then
            exec /usr/sbin/usernetctl ${CONFIG} down
        fi
    fi
    echo $"Users cannot control this device." >&2
    exit 1
fi

source_config

if [ -n "$IN_HOTPLUG" ] && [ "${HOTPLUG}" = "no" -o "${HOTPLUG}" = "NO" ]
then
    exit 0
fi

if [ "$_use_nm" = "true" ]; then
    if [ -n "$UUID" -a -z "$DEVICE" ]; then
        DEVICE=$(nmcli -t --fields uuid,device con show --active | awk -F ':' "\$1 == \"$UUID\" { print \$2 }")
    fi
    if [ -n "$DEVICE" ] && ! is_nm_device_unmanaged "$DEVICE" ; then
        if ! LC_ALL=C nmcli -t -f STATE,DEVICE dev status | egrep -q "^(failed|disconnected|unmanaged|unavailable):$DEVICE$"; then
            nmcli dev disconnect "$DEVICE"
            exit $?
        fi
        exit 0
    fi
fi

if [ -x /sbin/ifdown-pre-local ]; then
    /sbin/ifdown-pre-local ${DEVICE}
fi

OTHERSCRIPT="/etc/sysconfig/network-scripts/ifdown-${DEVICETYPE}"

if [ ! -x ${OTHERSCRIPT} ]; then
    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifdown-${TYPE}"
fi

if [ ! -x ${OTHERSCRIPT} ]; then
    OTHERSCRIPT="/etc/sysconfig/network-scripts/ifdown-eth"
fi

exec ${OTHERSCRIPT} ${CONFIG} $2

```



### profile

```shell
# /etc/profile

# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

pathmunge () {
    case ":${PATH}:" in
        *:"$1":*)
            ;;
        *)
            if [ "$2" = "after" ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
}


if [ -x /usr/bin/id ]; then
    if [ -z "$EUID" ]; then
        # ksh workaround
        EUID=`/usr/bin/id -u`
        UID=`/usr/bin/id -ru`
    fi
    USER="`/usr/bin/id -un`"
    LOGNAME=$USER
    MAIL="/var/spool/mail/$USER"
fi

# Path manipulation
if [ "$EUID" = "0" ]; then
    pathmunge /usr/sbin
    pathmunge /usr/local/sbin
else
    pathmunge /usr/local/sbin after
    pathmunge /usr/sbin after
fi

HOSTNAME=`/usr/bin/hostname 2>/dev/null`
HISTSIZE=1000
if [ "$HISTCONTROL" = "ignorespace" ] ; then
    export HISTCONTROL=ignoreboth
else
    export HISTCONTROL=ignoredups
fi

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL

# By default, we want umask to get set. This sets it for login shell
# Current threshold for system reserved uid/gids is 200
# You could check uidgid reservation validity in
# /usr/share/doc/setup-*/uidgid file
if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
    umask 002
else
    umask 022
fi

for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r "$i" ]; then
        if [ "${-#*i}" != "$-" ]; then 
            . "$i"
        else
            . "$i" >/dev/null
        fi
    fi
done

unset i
unset -f pathmunge
export JAVA_HOME=/opt/jdk8u262-b10
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:/$JAVA_HOME/bin:/usr/local/bin
export MAVEN_HOME=/opt/apache-maven-3.8.2
export PATH=$PATH:$MAVEN_HOME/bin

```

### bashrc

```shell
# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

# are we an interactive shell?
if [ "$PS1" ]; then
  if [ -z "$PROMPT_COMMAND" ]; then
    case $TERM in
    xterm*|vte*)
      if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
          PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
      elif [ "${VTE_VERSION:-0}" -ge 3405 ]; then
          PROMPT_COMMAND="__vte_prompt_command"
      else
          PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/~}"'
      fi
      ;;
    screen*)
      if [ -e /etc/sysconfig/bash-prompt-screen ]; then
          PROMPT_COMMAND=/etc/sysconfig/bash-prompt-screen
      else
          PROMPT_COMMAND='printf "\033k%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/~}"'
      fi
      ;;
    *)
      [ -e /etc/sysconfig/bash-prompt-default ] && PROMPT_COMMAND=/etc/sysconfig/bash-prompt-default
      ;;
    esac
  fi
  # Turn on parallel history
  shopt -s histappend
  history -a
  # Turn on checkwinsize
  shopt -s checkwinsize
  [ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
  # You might want to have e.g. tty in prompt (e.g. more virtual machines)
  # and console windows
  # If you want to do so, just add e.g.
  # if [ "$PS1" ]; then
  #   PS1="[\u@\h:\l \W]\\$ "
  # fi
  # to your custom modification shell script in /etc/profile.d/ directory
fi

if ! shopt -q login_shell ; then # We're not a login shell
    # Need to redefine pathmunge, it get's undefined at the end of /etc/profile
    pathmunge () {
        case ":${PATH}:" in
            *:"$1":*)
                ;;
            *)
                if [ "$2" = "after" ] ; then
                    PATH=$PATH:$1
                else
                    PATH=$1:$PATH
                fi
        esac
    }

    # By default, we want umask to get set. This sets it for non-login shell.
    # Current threshold for system reserved uid/gids is 200
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
       umask 002
    else
       umask 022
    fi

    SHELL=/bin/bash
    # Only display echos from profile.d scripts if we are no login shell
    # and interactive - otherwise just process them to set envvars
    for i in /etc/profile.d/*.sh; do
        if [ -r "$i" ]; then
            if [ "$PS1" ]; then
                . "$i"
            else
                . "$i" >/dev/null
            fi
        fi
    done

    unset i
    unset -f pathmunge
fi
# vim:ts=4:sw=4
```

### mysql: entrypoint.sh
```shell
#!/bin/bash
set -eo pipefail
shopt -s nullglob

# logging functions
mysql_log() {
	local type="$1"; shift
	# accept argument string or stdin
	local text="$*"; if [ "$#" -eq 0 ]; then text="$(cat)"; fi
	local dt; dt="$(date --rfc-3339=seconds)"
	printf '%s [%s] [Entrypoint]: %s\n' "$dt" "$type" "$text"
}
mysql_note() {
	mysql_log Note "$@"
}
mysql_warn() {
	mysql_log Warn "$@" >&2
}
mysql_error() {
	mysql_log ERROR "$@" >&2
	exit 1
}

# usage: file_env VAR [DEFAULT]
#    ie: file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
file_env() {
	local var="$1"
	local fileVar="${var}_FILE"
	local def="${2:-}"
	if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
		mysql_error "Both $var and $fileVar are set (but are exclusive)"
	fi
	local val="$def"
	if [ "${!var:-}" ]; then
		val="${!var}"
	elif [ "${!fileVar:-}" ]; then
		val="$(< "${!fileVar}")"
	fi
	export "$var"="$val"
	unset "$fileVar"
}

# check to see if this file is being run or sourced from another script
_is_sourced() {
	# https://unix.stackexchange.com/a/215279
	[ "${#FUNCNAME[@]}" -ge 2 ] \
		&& [ "${FUNCNAME[0]}" = '_is_sourced' ] \
		&& [ "${FUNCNAME[1]}" = 'source' ]
}

# usage: docker_process_init_files [file [file [...]]]
#    ie: docker_process_init_files /always-initdb.d/*
# process initializer files, based on file extensions
docker_process_init_files() {
	# mysql here for backwards compatibility "${mysql[@]}"
	mysql=( docker_process_sql )

	echo
	local f
	for f; do
		case "$f" in
			*.sh)
				# https://github.com/docker-library/postgres/issues/450#issuecomment-393167936
				# https://github.com/docker-library/postgres/pull/452
				if [ -x "$f" ]; then
					mysql_note "$0: running $f"
					"$f"
				else
					mysql_note "$0: sourcing $f"
					. "$f"
				fi
				;;
			*.sql)    mysql_note "$0: running $f"; docker_process_sql < "$f"; echo ;;
			*.sql.gz) mysql_note "$0: running $f"; gunzip -c "$f" | docker_process_sql; echo ;;
			*.sql.xz) mysql_note "$0: running $f"; xzcat "$f" | docker_process_sql; echo ;;
			*)        mysql_warn "$0: ignoring $f" ;;
		esac
		echo
	done
}

# arguments necessary to run "mysqld --verbose --help" successfully (used for testing configuration validity and for extracting default/configured values)
_verboseHelpArgs=(
	--verbose --help
	--log-bin-index="$(mktemp -u)" # https://github.com/docker-library/mysql/issues/136
)

mysql_check_config() {
	local toRun=( "$@" "${_verboseHelpArgs[@]}" ) errors
	if ! errors="$("${toRun[@]}" 2>&1 >/dev/null)"; then
		mysql_error $'mysqld failed while attempting to check config\n\tcommand was: '"${toRun[*]}"$'\n\t'"$errors"
	fi
}

# Fetch value from server config
# We use mysqld --verbose --help instead of my_print_defaults because the
# latter only show values present in config files, and not server defaults
mysql_get_config() {
	local conf="$1"; shift
	"$@" "${_verboseHelpArgs[@]}" 2>/dev/null \
		| awk -v conf="$conf" '$1 == conf && /^[^ \t]/ { sub(/^[^ \t]+[ \t]+/, ""); print; exit }'
	# match "datadir      /some/path with/spaces in/it here" but not "--xyz=abc\n     datadir (xyz)"
}

# Do a temporary startup of the MySQL server, for init purposes
docker_temp_server_start() {
	if [ "${MYSQL_MAJOR}" = '5.6' ] || [ "${MYSQL_MAJOR}" = '5.7' ]; then
		"$@" --skip-networking --default-time-zone=SYSTEM --socket="${SOCKET}" &
		mysql_note "Waiting for server startup"
		local i
		for i in {30..0}; do
			# only use the root password if the database has already been initialized
			# so that it won't try to fill in a password file when it hasn't been set yet
			extraArgs=()
			if [ -z "$DATABASE_ALREADY_EXISTS" ]; then
				extraArgs+=( '--dont-use-mysql-root-password' )
			fi
			if docker_process_sql "${extraArgs[@]}" --database=mysql <<<'SELECT 1' &> /dev/null; then
				break
			fi
			sleep 1
		done
		if [ "$i" = 0 ]; then
			mysql_error "Unable to start server."
		fi
	else
		# For 5.7+ the server is ready for use as soon as startup command unblocks
		if ! "$@" --daemonize --skip-networking --default-time-zone=SYSTEM --socket="${SOCKET}"; then
			mysql_error "Unable to start server."
		fi
	fi
}

# Stop the server. When using a local socket file mysqladmin will block until
# the shutdown is complete.
docker_temp_server_stop() {
	if ! mysqladmin --defaults-extra-file=<( _mysql_passfile ) shutdown -uroot --socket="${SOCKET}"; then
		mysql_error "Unable to shut down server."
	fi
}

# Verify that the minimally required password settings are set for new databases.
docker_verify_minimum_env() {
	if [ -z "$MYSQL_ROOT_PASSWORD" -a -z "$MYSQL_ALLOW_EMPTY_PASSWORD" -a -z "$MYSQL_RANDOM_ROOT_PASSWORD" ]; then
		mysql_error <<-'EOF'
			Database is uninitialized and password option is not specified
			    You need to specify one of the following:
			    - MYSQL_ROOT_PASSWORD
			    - MYSQL_ALLOW_EMPTY_PASSWORD
			    - MYSQL_RANDOM_ROOT_PASSWORD
		EOF
	fi

	# This will prevent the CREATE USER from failing (and thus exiting with a half-initialized database)
	if [ "$MYSQL_USER" = 'root' ]; then
		mysql_error <<-'EOF'
			MYSQL_USER="root", MYSQL_USER and MYSQL_PASSWORD are for configuring a regular user and cannot be used for the root user
			    Remove MYSQL_USER="root" and use one of the following to control the root user password:
			    - MYSQL_ROOT_PASSWORD
			    - MYSQL_ALLOW_EMPTY_PASSWORD
			    - MYSQL_RANDOM_ROOT_PASSWORD
		EOF
	fi

	# warn when missing one of MYSQL_USER or MYSQL_PASSWORD
	if [ -n "$MYSQL_USER" ] && [ -z "$MYSQL_PASSWORD" ]; then
		mysql_warn 'MYSQL_USER specified, but missing MYSQL_PASSWORD; MYSQL_USER will not be created'
	elif [ -z "$MYSQL_USER" ] && [ -n "$MYSQL_PASSWORD" ]; then
		mysql_warn 'MYSQL_PASSWORD specified, but missing MYSQL_USER; MYSQL_PASSWORD will be ignored'
	fi
}

# creates folders for the database
# also ensures permission for user mysql of run as root
docker_create_db_directories() {
	local user; user="$(id -u)"

	# TODO other directories that are used by default? like /var/lib/mysql-files
	# see https://github.com/docker-library/mysql/issues/562
	mkdir -p "$DATADIR"

	if [ "$user" = "0" ]; then
		# this will cause less disk access than `chown -R`
		find "$DATADIR" \! -user mysql -exec chown mysql '{}' +
	fi
}

# initializes the database directory
docker_init_database_dir() {
	mysql_note "Initializing database files"
	if [ "$MYSQL_MAJOR" = '5.6' ]; then
		mysql_install_db --datadir="$DATADIR" --rpm --keep-my-cnf "${@:2}" --default-time-zone=SYSTEM
	else
		"$@" --initialize-insecure --default-time-zone=SYSTEM
	fi
	mysql_note "Database files initialized"

	if command -v mysql_ssl_rsa_setup > /dev/null && [ ! -e "$DATADIR/server-key.pem" ]; then
		# https://github.com/mysql/mysql-server/blob/23032807537d8dd8ee4ec1c4d40f0633cd4e12f9/packaging/deb-in/extra/mysql-systemd-start#L81-L84
		mysql_note "Initializing certificates"
		mysql_ssl_rsa_setup --datadir="$DATADIR"
		mysql_note "Certificates initialized"
	fi
}

# Loads various settings that are used elsewhere in the script
# This should be called after mysql_check_config, but before any other functions
docker_setup_env() {
	# Get config
	declare -g DATADIR SOCKET
	DATADIR="$(mysql_get_config 'datadir' "$@")"
	SOCKET="$(mysql_get_config 'socket' "$@")"

	# Initialize values that might be stored in a file
	file_env 'MYSQL_ROOT_HOST' '%'
	file_env 'MYSQL_DATABASE'
	file_env 'MYSQL_USER'
	file_env 'MYSQL_PASSWORD'
	file_env 'MYSQL_ROOT_PASSWORD'

	declare -g DATABASE_ALREADY_EXISTS
	if [ -d "$DATADIR/mysql" ]; then
		DATABASE_ALREADY_EXISTS='true'
	fi
}

# Execute sql script, passed via stdin
# usage: docker_process_sql [--dont-use-mysql-root-password] [mysql-cli-args]
#    ie: docker_process_sql --database=mydb <<<'INSERT ...'
#    ie: docker_process_sql --dont-use-mysql-root-password --database=mydb <my-file.sql
docker_process_sql() {
	passfileArgs=()
	if [ '--dont-use-mysql-root-password' = "$1" ]; then
		passfileArgs+=( "$1" )
		shift
	fi
	# args sent in can override this db, since they will be later in the command
	if [ -n "$MYSQL_DATABASE" ]; then
		set -- --database="$MYSQL_DATABASE" "$@"
	fi

	mysql --defaults-extra-file=<( _mysql_passfile "${passfileArgs[@]}") --protocol=socket -uroot -hlocalhost --socket="${SOCKET}" --comments "$@"
}

# Initializes database with timezone info and root password, plus optional extra db/user
docker_setup_db() {
	# Load timezone info into database
	if [ -z "$MYSQL_INITDB_SKIP_TZINFO" ]; then
		# sed is for https://bugs.mysql.com/bug.php?id=20545
		mysql_tzinfo_to_sql /usr/share/zoneinfo \
			| sed 's/Local time zone must be set--see zic manual page/FCTY/' \
			| docker_process_sql --dont-use-mysql-root-password --database=mysql
			# tell docker_process_sql to not use MYSQL_ROOT_PASSWORD since it is not set yet
	fi
	# Generate random root password
	if [ -n "$MYSQL_RANDOM_ROOT_PASSWORD" ]; then
		export MYSQL_ROOT_PASSWORD="$(pwgen -1 32)"
		mysql_note "GENERATED ROOT PASSWORD: $MYSQL_ROOT_PASSWORD"
	fi
	# Sets root password and creates root users for non-localhost hosts
	local rootCreate=
	# default root to listen for connections from anywhere
	if [ -n "$MYSQL_ROOT_HOST" ] && [ "$MYSQL_ROOT_HOST" != 'localhost' ]; then
		# no, we don't care if read finds a terminating character in this heredoc
		# https://unix.stackexchange.com/questions/265149/why-is-set-o-errexit-breaking-this-read-heredoc-expression/265151#265151
		read -r -d '' rootCreate <<-EOSQL || true
			CREATE USER 'root'@'${MYSQL_ROOT_HOST}' IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}' ;
			GRANT ALL ON *.* TO 'root'@'${MYSQL_ROOT_HOST}' WITH GRANT OPTION ;
		EOSQL
	fi

	local passwordSet=
	if [ "$MYSQL_MAJOR" = '5.6' ]; then
		# no, we don't care if read finds a terminating character in this heredoc (see above)
		read -r -d '' passwordSet <<-EOSQL || true
			DELETE FROM mysql.user WHERE user NOT IN ('mysql.sys', 'mysqlxsys', 'root') OR host NOT IN ('localhost') ;
			SET PASSWORD FOR 'root'@'localhost'=PASSWORD('${MYSQL_ROOT_PASSWORD}') ;

			-- 5.5: https://github.com/mysql/mysql-server/blob/e48d775c6f066add457fa8cfb2ebc4d5ff0c7613/scripts/mysql_secure_installation.sh#L192-L210
			-- 5.6: https://github.com/mysql/mysql-server/blob/06bc670db0c0e45b3ea11409382a5c315961f682/scripts/mysql_secure_installation.sh#L218-L236
			-- 5.7: https://github.com/mysql/mysql-server/blob/913071c0b16cc03e703308250d795bc381627e37/client/mysql_secure_installation.cc#L792-L818
			-- 8.0: https://github.com/mysql/mysql-server/blob/b93c1661d689c8b7decc7563ba15f6ed140a4eb6/client/mysql_secure_installation.cc#L726-L749
			DELETE FROM mysql.db WHERE Db='test' OR Db='test\_%' ;
			-- https://github.com/docker-library/mysql/pull/479#issuecomment-414561272 ("This is only needed for 5.5 and 5.6")
		EOSQL
	else
		# no, we don't care if read finds a terminating character in this heredoc (see above)
		read -r -d '' passwordSet <<-EOSQL || true
			ALTER USER 'root'@'localhost' IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}' ;
		EOSQL
	fi

	# tell docker_process_sql to not use MYSQL_ROOT_PASSWORD since it is just now being set
	docker_process_sql --dont-use-mysql-root-password --database=mysql <<-EOSQL
		-- What's done in this file shouldn't be replicated
		--  or products like mysql-fabric won't work
		SET @@SESSION.SQL_LOG_BIN=0;

		${passwordSet}
		GRANT ALL ON *.* TO 'root'@'localhost' WITH GRANT OPTION ;
		FLUSH PRIVILEGES ;
		${rootCreate}
		DROP DATABASE IF EXISTS test ;
	EOSQL

	# Creates a custom database and user if specified
	if [ -n "$MYSQL_DATABASE" ]; then
		mysql_note "Creating database ${MYSQL_DATABASE}"
		docker_process_sql --database=mysql <<<"CREATE DATABASE IF NOT EXISTS \`$MYSQL_DATABASE\` ;"
	fi

	if [ -n "$MYSQL_USER" ] && [ -n "$MYSQL_PASSWORD" ]; then
		mysql_note "Creating user ${MYSQL_USER}"
		docker_process_sql --database=mysql <<<"CREATE USER '$MYSQL_USER'@'%' IDENTIFIED BY '$MYSQL_PASSWORD' ;"

		if [ -n "$MYSQL_DATABASE" ]; then
			mysql_note "Giving user ${MYSQL_USER} access to schema ${MYSQL_DATABASE}"
			docker_process_sql --database=mysql <<<"GRANT ALL ON \`${MYSQL_DATABASE//_/\\_}\`.* TO '$MYSQL_USER'@'%' ;"
		fi
	fi
}

_mysql_passfile() {
	# echo the password to the "file" the client uses
	# the client command will use process substitution to create a file on the fly
	# ie: --defaults-extra-file=<( _mysql_passfile )
	if [ '--dont-use-mysql-root-password' != "$1" ] && [ -n "$MYSQL_ROOT_PASSWORD" ]; then
		cat <<-EOF
			[client]
			password="${MYSQL_ROOT_PASSWORD}"
		EOF
	fi
}

# Mark root user as expired so the password must be changed before anything
# else can be done (only supported for 5.6+)
mysql_expire_root_user() {
	if [ -n "$MYSQL_ONETIME_PASSWORD" ]; then
		docker_process_sql --database=mysql <<-EOSQL
			ALTER USER 'root'@'%' PASSWORD EXPIRE;
		EOSQL
	fi
}

# check arguments for an option that would cause mysqld to stop
# return true if there is one
_mysql_want_help() {
	local arg
	for arg; do
		case "$arg" in
			-'?'|--help|--print-defaults|-V|--version)
				return 0
				;;
		esac
	done
	return 1
}

_main() {
	# if command starts with an option, prepend mysqld
	if [ "${1:0:1}" = '-' ]; then
		set -- mysqld "$@"
	fi

	# skip setup if they aren't running mysqld or want an option that stops mysqld
	if [ "$1" = 'mysqld' ] && ! _mysql_want_help "$@"; then
		mysql_note "Entrypoint script for MySQL Server ${MYSQL_VERSION} started."

		mysql_check_config "$@"
		# Load various environment variables
		docker_setup_env "$@"
		docker_create_db_directories

		# If container is started as root user, restart as dedicated mysql user
		if [ "$(id -u)" = "0" ]; then
			mysql_note "Switching to dedicated user 'mysql'"
			exec gosu mysql "$BASH_SOURCE" "$@"
		fi

		# there's no database, so it needs to be initialized
		if [ -z "$DATABASE_ALREADY_EXISTS" ]; then
			docker_verify_minimum_env

			# check dir permissions to reduce likelihood of half-initialized database
			ls /docker-entrypoint-initdb.d/ > /dev/null

			docker_init_database_dir "$@"

			mysql_note "Starting temporary server"
			docker_temp_server_start "$@"
			mysql_note "Temporary server started."

			docker_setup_db
			docker_process_init_files /docker-entrypoint-initdb.d/*

			mysql_expire_root_user

			mysql_note "Stopping temporary server"
			docker_temp_server_stop
			mysql_note "Temporary server stopped"

			echo
			mysql_note "MySQL init process done. Ready for start up."
			echo
		fi
	fi
	exec "$@"
}

# If we are sourced from elsewhere, don't perform any further actions
if ! _is_sourced; then
	_main "$@"
fi
```



# End

